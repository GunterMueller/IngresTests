/*
	Test Name: api03.sep
	Time: Thu Mar 27 10:25:38 1997
	User Name: testenv
	Terminal type: septerm
 
	Test ID : api03.sep
	Module  : be/lar 
	Filename: api03.sep
	Purpose	: To test function IIapi_getCopyMap() and IIapi_putColumn() in
		  API with asynchronous.
	Input Files  :
	Output Files :
	Database     :
	Tables       :
	Synopsis     :

 History: 27-Mar-1997	zhaqi01         Created
	2-Arp-1999      (yu$pe02)       Hard code to 4K.
	17-Aug-1999     (matbe01)       Removed buffer[80] and the assignment
				  involving buffer from IIAPI_getCopyMap().
				  This invalid attempt to initialize dv_value
				  resulted in a bus error for several platforms.
				  (See myquery.c).
          17-Aug-1999   (hweho01)       Added stdlib.h header file in myfile.c
                                        and myquery.c source files, it 
                                        provides the function prototype of 
                                        malloc(). Without the declaration, the  
                                        default int return type will result in
                                        64-bit address being truncated on 
                                        ris_u64 platform.
          05-Jan-2000	(ngutr03)	Changed initP.in_version from IIAPI_VERSION_1 to 
                                        IIAPI_VERSION_2 (see myaccess.c)
					Added new member variable in_envHandle to initP 
					structure (see myaccess.c)
					Added new API function IIapi_releaseEnv() to
					myaccess.c to release the environment handle.
					Fixed the display_fdatadescr() function in
					myfile.c because when fd_nullDescr.ds_dataType = IIAPI_VCH_TYPE
					then the first two bytes are reservered for the length. Therefore,
					before displaying the value of fd_nullValue.dv_value
					the pointer must move forward by 2.
	11-jun-2003 (abbjo03)
		Corrections to eliminate warnings on VMS.
*/
? fill a.tes 
!!
            2	    5bbbbb
!!
? cp @file(ii_system,ingres,files,iiapidep.h) iiapidep.h 
<<

>>
? cp @file(ii_system,ingres,files,iiapi.h) iiapi.tmp 
<<

>>
.if (NT_GENERIC) 
? fill makeiiapi.bat 
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h
!!
? run makeiiapi.bat 
<<

>>
.endif 
.if (UNIX) 
? fill makeiiapi.sh 
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h
!!
? sh makeiiapi.sh 
<<

>>
.endif 
.if (VMS)
? fill iiapi_edit.com
!!
$ pipe sed "s/<iiapidep.h>/""iiapidep.h""/g" iiapi.tmp > iiapi.h
!!
? qasetuser testenv @iiapi_edit.com
<<
>>
.endif
? fill myaccess.h 
!!
#ifndef II_ACCESS_H
#define II_ACCESS_H

extern II_PTR API_initialize(void);
extern void API_terminate(void);
extern void API_releaseEnv(II_PTR);

#endif /* II_ACCESS_H */
!!
? fill myaccess.c 
!!
#include <stdio.h>
#include <stdlib.h>
#include "iiapi.h"
#include "myaccess.h"

/* IIapi_initialize() */

extern II_PTR
API_initialize(void)
{
    IIAPI_INITPARM initP;
    
    initP.in_timeout = -1;
    initP.in_version = IIAPI_VERSION_2;
    initP.in_envHandle = NULL;

    printf("Initializing API ...\n");
    IIapi_initialize(&initP);

    if (initP.in_status != IIAPI_ST_SUCCESS) {
	printf("\t=>Error in IIapi_initialize: %d\n", initP.in_status);
	exit(0);
    }

    return (initP.in_envHandle);
}

/* release environment handle */
extern void
API_releaseEnv(II_PTR envHandle)
{
	IIAPI_RELENVPARM relEnvParm;

	relEnvParm.re_envHandle = envHandle;
	printf("Releasing API environment...\n");
	IIapi_releaseEnv(&relEnvParm);
	printf("%s\n", (relEnvParm.re_status == IIAPI_ST_SUCCESS) ? "Successfully, released-
 API environment" : "Failed to release API environment");
}


/* IIapi_terminate() */

extern void
API_terminate(void)
{
    IIAPI_TERMPARM termP;

    printf("Shutting down API ...\n");
    IIapi_terminate(&termP);

    if (termP.tm_status != IIAPI_ST_SUCCESS) {
	printf("\t=>Error in IIapi_terminate: %d\n", termP.tm_status);
	exit(0);
    }

    return;
}
!!
? fill myfile.h 
!!
#ifndef MYFILE_H
#define MYFILE_H

extern void display_descriptor (IIAPI_DESCRIPTOR *iiapi_descriptor,int nullIndex);

extern void display_fdatadescr (IIAPI_FDATADESCR *iiapi_fdatadescr);

extern  char* IIsyc_printData( IIAPI_DESCRIPTOR *descriptor,IIAPI_DATAVALUE *dataVal-
ue, char *buffer );

extern  void IIsyc_free( II_PTR      buffer );

extern  char* IIsyc_stalloc( char     *src );

extern  II_PTR IIsyc_malloc( int       size );

static void syc_formatString( char *string,int length, char  *buffer );
#endif
!!
? fill myfile.c 
!!
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "iiapi.h"
#include "myfile.h"

extern void display_descriptor(IIAPI_DESCRIPTOR *iiapi_descriptor,int nullIndex)
{
   printf("The data type is::\t");
   switch (iiapi_descriptor->ds_dataType)
   {
      case IIAPI_BYTE_TYPE:
         printf("IIAPI_BYTE_TYPE");
         break;
      case IIAPI_CHA_TYPE:
         printf("IIAPI_CHA_TYPE");
         break;
      case IIAPI_CHR_TYPE:
         printf("IIAPI_CHR_TYPE");
         break;
      case IIAPI_HNDL_TYPE:
         printf("IIAPI_APIHNDL_TYPE");
         break;
      case IIAPI_DEC_TYPE:
         printf("IIAPI_DEC_TYPE");
         break;
      case IIAPI_DTE_TYPE:
         printf("IIAPI_DTE_TYPE");
         break;
      case IIAPI_FLT_TYPE:
         printf("IIAPI_FLT_TYPE");
         break;
      case IIAPI_INT_TYPE:
         printf("IIAPI_INT_TYPE");
         break;
      case IIAPI_LOGKEY_TYPE:
         printf("IIAPI_LOGKEY_TYPE");
         break;
      case IIAPI_LBYTE_TYPE:
         printf("IIAPI_LBYTE_TYPE");
         break;
      case IIAPI_LVCH_TYPE:
         printf("IIAPI_LVCH_TYPE");
         break;
      case IIAPI_MNY_TYPE:
         printf("IIAPI_MNY_TYPE");
         break;
      case IIAPI_TABKEY_TYPE:
         printf("IIAPI_TABKEY_TYPE");
         break;
      case IIAPI_TXT_TYPE:
         printf("IIAPI_TXT_TYPE");
         break;
      case IIAPI_VBYTE_TYPE:
         printf("IIAPI_VBYTE_TYPE");
         break;
      case IIAPI_VCH_TYPE:
         printf("IIAPI_VCH_TYPE");
         break;
      default:
         printf("unknown type");
         break;
     }
     printf("\nData is nullable or not:\t");
     switch (iiapi_descriptor->ds_nullable)
     {
         case TRUE:
            printf("TRUE");
            break;
         case FALSE:
            printf("FALSE");
            break;
         default:
            printf("unknown: %d", iiapi_descriptor->ds_nullable);
            break;
    }
    printf("\nThe length of the value being described: %ld\n", 
           iiapi_descriptor->ds_length);
    switch (iiapi_descriptor->ds_dataType)
    {
        case IIAPI_DEC_TYPE:
           printf("The scale of value: %ld\n", iiapi_descriptor->ds_scale);
        case IIAPI_MNY_TYPE:
        case IIAPI_FLT_TYPE:
        printf("The precision of the value: %ld\n",
                            iiapi_descriptor->ds_precision);
    }
    printf("The usage of the value being described: ");
    switch (iiapi_descriptor->ds_columnType)
    {
        case IIAPI_COL_TUPLE:
           printf("IIAPI_COL_TUPLE\n");
           break;
        case IIAPI_COL_PROCBYREFPARM:
           printf("IIAPI_COL_PROCBYREFPARM\n");
           break;
        case IIAPI_COL_PROCPARM:
           printf("IIAPI_COL_PROCPARM\n");
           break;
        case IIAPI_COL_SVCPARM:
           printf("IIAPI_COL_SVCPARM\n");
           break;
        case IIAPI_COL_QPARM:
           printf("IIAPI_COL_QPARM\n");
           break;
        default:
           printf("unknown type\n");
           break;
   }
   
   if (!nullIndex)
      printf("The column Name is: %s\n", iiapi_descriptor->ds_columnName);

   return;
}

void display_fdatadescr(IIAPI_FDATADESCR *iiapi_fdatadescr)
{
   char buffer[80]={'\0'};
   char *dp;
   int  length;

   printf("The separator between columns: ");
   switch (iiapi_fdatadescr->fd_delimiter)
   {
      case TRUE:
      {
         char *delimiter;
         int lenOfDelimiter;

         printf("TRUE");
         printf("\nThe length of the separator:\t%d", lenOfDelimiter =
				 iiapi_fdatadescr->fd_delimLength);
         delimiter = (char *) malloc(lenOfDelimiter + 1);
         strncpy(delimiter, iiapi_fdatadescr->fd_delimValue, lenOfDelimiter);
         delimiter[lenOfDelimiter] = '\0';
         printf("\nThe value of the separator: %s", delimiter);
         free(delimiter);
         break;
      }
      case FALSE:
         printf("FALSE");
         break;
      default:
         printf("Unknown: %d", iiapi_fdatadescr->fd_delimiter);
         break;
      }
      printf("\n");
 
      printf("The allowance of a null value in the column: ");
      switch (iiapi_fdatadescr->fd_nullable)
      {
         case TRUE:
            printf("TRUE");
            printf("\nIs null value provide: ");
            switch (iiapi_fdatadescr->fd_nullInfo)
            {
                case TRUE:
		   length = iiapi_fdatadescr->fd_nullValue.dv_length;
		   dp = iiapi_fdatadescr->fd_nullValue.dv_value;
		   if (iiapi_fdatadescr->fd_nullDescr.ds_dataType == IIAPI_VCH_TYPE)
		   {
			length -= 2;
			dp += 2;
		   }
		   memcpy(buffer, dp, length);

                   printf("TRUE\n");
                   display_descriptor(&iiapi_fdatadescr->fd_nullDescr,1);
		   printf("Whether the value is null : %d \n",
		           iiapi_fdatadescr->fd_nullValue.dv_null);
		   printf("The length of null symbole: %d\n",
 			   iiapi_fdatadescr->fd_nullValue.dv_length);

		   printf("The value of the null: %s\n",
			   buffer);
                   break;
                case FALSE:
                   printf("FALSE");
                   break;
                default:
                   printf("Unknown: %d", 
                            iiapi_fdatadescr->fd_nullInfo);
                   break;
            }
            break;
         case FALSE:
            printf("FALSE");
            break;
         default:
            printf("Unknown: %d", iiapi_fdatadescr->fd_nullable);
            break;
       }
    printf("\n");
 
    return;
}

extern  char*
IIsyc_printData( IIAPI_DESCRIPTOR       *descriptor,
                 IIAPI_DATAVALUE        *dataValue,
                 char                   *buffer )
{
    IIAPI_CONVERTPARM   cv;
    char                *buf = buffer;
    int                 i;
    II_INT2             length;
    II_FLOAT4           *float4;
    II_FLOAT8           *float8;
    II_INT1             *integer1;
    II_INT2             *integer2;
    II_INT4             *integer4;
 
    if ( dataValue->dv_null )
    {
        II_sprintf( buffer, "( NULL )" );
        return ( buffer );
    }
 
    switch( abs( descriptor->ds_dataType ) )
    {
        case IIAPI_LOGKEY_TYPE:
        case IIAPI_TABKEY_TYPE:
            for( i = 0; i<dataValue->dv_length; i++ )
            {
                char c, d;
 
                c = ( ( II_CHAR * ) dataValue->dv_value )[i];
                d = ( c >> 4 ) & 0x0f;
                *buf++ = ( d < 10 ) ? d + '0' : (d - 10) + 'A';
                d = c & 0x0f;
                *buf++ = ( d < 10 ) ? d + '0' : (d - 10) + 'A';
                *buf++ = ' ';
            }
            *buf = '\0';
            break;
 
        case IIAPI_LBYTE_TYPE:
        case IIAPI_LTXT_TYPE:
        case IIAPI_LVCH_TYPE:
        case IIAPI_TXT_TYPE:
        case IIAPI_VBYTE_TYPE:
        case IIAPI_VCH_TYPE:
            memcpy( &length, dataValue->dv_value, sizeof( length ) );
            syc_formatString( (char *)dataValue->dv_value + sizeof( length ),
                              (int)length, buffer );
            break;
 
        case IIAPI_BYTE_TYPE:
        case IIAPI_CHA_TYPE:
        case IIAPI_CHR_TYPE:
            syc_formatString( (char *)dataValue->dv_value,
                              (int)dataValue->dv_length, buffer );
            break;
 
        case IIAPI_FLT_TYPE:
            switch( dataValue->dv_length )
            {
                case 4:
                    float4 = (II_FLOAT4 *)dataValue->dv_value;
                    II_sprintf( buffer, "%f", (II_FLOAT8)*float4 );
                    break;
 
                case 8:
                    float8 = (II_FLOAT8 *)dataValue->dv_value;
                    II_sprintf( buffer, "%f", *float8 );
                    break;
 
                default:
                    II_sprintf( buffer, "invalid float length" );
                    break;
            }
            break;
 
        case IIAPI_INT_TYPE:
            switch( dataValue->dv_length )
            {
                case 1:
                    integer1 = (II_INT1 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer1 );
                    break;
 
                case 2:
                    integer2 = (II_INT2 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer2 );
                    break;
 
                case 4:
                    integer4 = (II_INT4 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer4 );
                    break;
 
                default:
                    II_sprintf( buffer, "invalid integer length" );
                    break;
            }
            break;
 
        case IIAPI_DTE_TYPE:
        case IIAPI_DEC_TYPE:
        case IIAPI_MNY_TYPE:
            cv.cv_srcDesc.ds_dataType = descriptor->ds_dataType;
            cv.cv_srcDesc.ds_nullable = descriptor->ds_nullable;
            cv.cv_srcDesc.ds_length = descriptor->ds_length;
            cv.cv_srcDesc.ds_precision = descriptor->ds_precision;
            cv.cv_srcDesc.ds_scale = descriptor->ds_scale;
            cv.cv_srcDesc.ds_columnType = descriptor->ds_columnType;
            cv.cv_srcDesc.ds_columnName = descriptor->ds_columnName;
 
            cv.cv_srcValue.dv_null = dataValue->dv_null;
            cv.cv_srcValue.dv_length = dataValue->dv_length;
            cv.cv_srcValue.dv_value = dataValue->dv_value;
 
            cv.cv_dstDesc.ds_dataType = IIAPI_CHA_TYPE;
            cv.cv_dstDesc.ds_nullable = FALSE;
            cv.cv_dstDesc.ds_length = 32;
            cv.cv_dstDesc.ds_precision = 0;
            cv.cv_dstDesc.ds_scale = 0;
            cv.cv_dstDesc.ds_columnType = IIAPI_COL_TUPLE;
            cv.cv_dstDesc.ds_columnName = NULL;
 
            cv.cv_dstValue.dv_null = FALSE;
            cv.cv_dstValue.dv_length = cv.cv_dstDesc.ds_length;
            cv.cv_dstValue.dv_value = buffer;
 
            IIapi_convertData( &cv );
 
            if ( cv.cv_status != IIAPI_ST_SUCCESS )
            {
                II_sprintf( buffer, "(invalid type)" );
                break;
            }
 
            buffer[ cv.cv_dstValue.dv_length ] = '\0';
            break;
 
        default:
            II_sprintf( buffer, "invalid type" );
            break;
    }
 
    return( buffer );
}
 
static void
syc_formatString( char          *string,
                  int           length,
                  char          *buffer )
{
    int i, j;
 
    if ( length > 72 )  *buffer++ = '\n';
    *buffer++ = '"';
 
    for ( j = 72; length > 0; length--, string++, j-- )
    {
        if ( ! j )
        {
            *buffer++ = '"';
            *buffer++ = '\n';
            *buffer++ = '"';
            j = 72;
        }
 
        if ( isprint( *string ) )
            *buffer++ = *string;
        else
        {
            II_sprintf( buffer, "\\%03.03d", *string );
            buffer += 4;
        }
    }
 
    *buffer++ = '"';
    *buffer = '\0';
}
 
extern  void
IIsyc_free( II_PTR      buffer )
{
    free( buffer );
 
    return;
}
 
extern  char*
IIsyc_stalloc( char     *src )
{
    char            *dest;
 
    dest = ( char * )IIsyc_malloc( strlen( src ) + 1 );
    strcpy( dest, src );
 
    return      ( dest );
}
 
extern  II_PTR
IIsyc_malloc( int       size )
{
    II_PTR          retValue;
 
    if ( ! ( retValue = ( II_PTR )malloc( size ) ) )
    {
        II_printf( "ERROR: cann't allocate size %d\n", size );
 
        exit( 0 );
    }
 
    return      ( retValue );
}
!!
? fill mymain.c 
!!
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "iiapi.h"
#include "myaccess.h"
#include "mysession.h"
#include "myquery.h"
#include "mytran.h"
#include "mymisc.h"
#include "myfile.h"
#include "mymain.h"

int main (int argc, char **argv)
{
  IIAPI_CONNPARM ConnParm;
  IIAPI_QUERYPARM QueryParm;
  II_PTR envHandle;

  envHandle = API_initialize();
  
  ConnParm.co_target = argv[1];
  ConnParm.co_connHandle = envHandle;

  API_connect(&ConnParm);

  dropTable(&ConnParm,&QueryParm);

  createTable(&ConnParm, &QueryParm);

  copyFrom(&ConnParm, &QueryParm);

  selectTable(&ConnParm, &QueryParm);

  dropTable(&ConnParm,&QueryParm);

  API_disconnect(&ConnParm);

  API_releaseEnv(envHandle);
  
  API_terminate();
  return (0);
}

extern void
dropTable(IIAPI_CONNPARM *connParm,IIAPI_QUERYPARM *QueryParm)
{
    int i;
    II_CHAR *sqlStmt = "drop table a";

    QueryParm->qy_queryText = sqlStmt;
    Middle(connParm,QueryParm);

    return;
}

extern void
Middle(IIAPI_CONNPARM *connParm,IIAPI_QUERYPARM *queryParm)
{
    printf("Now, database is doing %s\n",queryParm->qy_queryText);
    queryParm->qy_genParm.gp_callback = NULL;
    queryParm->qy_genParm.gp_closure = NULL;
    queryParm->qy_parameters = FALSE;
    queryParm->qy_stmtHandle = (II_PTR) NULL;
    queryParm->qy_queryType = IIAPI_QT_QUERY;

    API_query(connParm, queryParm);
    API_getQueryInfo(queryParm);
    API_close(queryParm);
    API_commit(queryParm);
    return;
}

extern void
createTable(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm)
{
   II_CHAR *sqlStmt = "create table a (i integer, a char(7) )with page_size=4096";
 
   queryParm->qy_queryText = sqlStmt;
   Middle(connParm,queryParm);
   return;
}

extern void
copyFrom(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm)
{
   II_CHAR *sqlStmt = "copy a (i = c0tab with null('NULL'), a= varchar(0)nl with nul-
l('NULL'), nl= d1) from 'a.tes'";
   IIAPI_GETCOPYMAPPARM iiapi_getcopymapparm;

   queryParm->qy_queryText = sqlStmt;
   printf("Now, database is doing %s\n",queryParm->qy_queryText);
   queryParm->qy_genParm.gp_callback = NULL;
   queryParm->qy_genParm.gp_closure = NULL;
   queryParm->qy_parameters = FALSE;
   queryParm->qy_stmtHandle = (II_PTR) NULL;
   queryParm->qy_queryType = IIAPI_QT_QUERY;

   API_query(connParm, queryParm);
   API_getCopyMap(&iiapi_getcopymapparm, queryParm);
   API_putColumns(&iiapi_getcopymapparm,queryParm);
   API_getQueryInfo(queryParm);
   API_close(queryParm);
   API_commit(queryParm);

   return;
}

extern void
selectTable(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm)
{
    II_CHAR *sqlstmt = "select * from a";
    IIAPI_GETDESCRPARM getDescrP;
    IIAPI_GETCOLPARM getColP;
    int i;

    queryParm->qy_queryText = sqlstmt;
    printf("Now, database is doing %s\n",queryParm->qy_queryText);
    queryParm->qy_genParm.gp_callback = NULL;
    queryParm->qy_genParm.gp_closure = NULL;
    queryParm->qy_parameters = FALSE;
    queryParm->qy_stmtHandle = (II_PTR) NULL;
    queryParm->qy_queryType = IIAPI_QT_QUERY;
 
    API_query(connParm, queryParm);
    i=API_getDescriptor(queryParm,&getDescrP);
    API_getColumns(&getDescrP,&getColP,i);
 
    API_getQueryInfo(queryParm);
    API_close(queryParm);
    API_commit(queryParm);
 
    return;
}
!!
? fill mymain.h 
!!
#ifndef _MAIN_
#define _MAIN_
#define MODULE
#define _ASC_

extern void
Middle(IIAPI_CONNPARM *connParm,IIAPI_QUERYPARM *QueryParm);

extern void
dropTable(IIAPI_CONNPARM *connParm,IIAPI_QUERYPARM *QueryParm);

extern void
createTable(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm);

extern void
copyFrom(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm);

extern void
selectTable(IIAPI_CONNPARM *connParm, IIAPI_QUERYPARM *queryParm);
#endif
!!
? fill mymisc.h 
!!
#ifndef II_MISC_H
#define II_MISC_H
 
extern II_BOOL API_wait(IIAPI_GENPARM *genP);
 
#endif /* II_MISC_H */
!!
? fill mymisc.c 
!!
#include <stdio.h>
#include <stdlib.h>
#include "iiapi.h"
#include "myquery.h"
#include "mymisc.h"
 
extern II_BOOL
API_wait(IIAPI_GENPARM *genP)
{
   IIAPI_WAITPARM waitP;
 
   waitP.wt_timeout = -1;
 
    printf("Synchronizing ...\n");
    while (!genP->gp_completed)
        IIapi_wait(&waitP);
 
    switch (genP->gp_status) {
        case IIAPI_ST_SUCCESS:
            printf("\t=>gp_status: IIAPI_ST_SUCCESS\n");
            break;
        case IIAPI_ST_MESSAGE:
            printf("\t=>gp_status: IIAPI_ST_MESSAGE\n");
            break;
        case IIAPI_ST_WARNING:
            printf("\t=>gp_status: IIAPI_ST_WARNING\n");
            break;
        case IIAPI_ST_NO_DATA:
            printf("\t=>gp_status: IIAPI_ST_NO_DATA\n");
            break;
        case IIAPI_ST_ERROR:
            printf("\t=>gp_status: IIAPI_ST_ERROR\n");
            break;
        case IIAPI_ST_FAILURE:
            printf("\t=>gp_status: IIAPI_ST_FAILURE\n");
            break;
        case IIAPI_ST_NOT_INITIALIZED:
            printf("\t=>gp_status: IIAPI_ST_NOT_INITIALIZED\n");
            break;
        case IIAPI_ST_INVALID_HANDLE:
            printf("\t=>gp_status: IIAPI_ST_INVALID_HANDLE\n");
            break;
        case IIAPI_ST_OUT_OF_MEMORY:
            printf("\t=>gp_status: IIAPI_ST_OUT_OF_MEMORY\n");
            break;
        default:
            printf("\t=>Unknown status\n");
            if(genP->gp_errorHandle)
            exit(0);
    }
 
    if (genP->gp_errorHandle)
        API_getErrorInfo(genP->gp_errorHandle);
 
    if (genP->gp_status == IIAPI_ST_SUCCESS ||
        genP->gp_status == IIAPI_ST_MESSAGE ||
        genP->gp_status == IIAPI_ST_WARNING)
        return(TRUE);
    else if (genP->gp_status == IIAPI_ST_NO_DATA)
        return(FALSE);
}
!!
? fill myquery.h 
!!
#ifndef II_QUERY_H
#define II_QUERY_H
 
extern void
API_getErrorInfo(II_PTR errorHandle);

extern void
API_query(IIAPI_CONNPARM *connP, IIAPI_QUERYPARM *queryP);

extern void
API_getQueryInfo(IIAPI_QUERYPARM *queryP);

extern void
API_close(IIAPI_QUERYPARM *queryP);

extern void
API_getCopyMap(IIAPI_GETCOPYMAPPARM *iiapi_getcopymapparm, IIAPI_QUERYPARM *queryP-
arm);

extern void
API_putColumns(IIAPI_GETCOPYMAPPARM *iiapi_getcopymapparm, IIAPI_QUERYPARM *queryP-
arm);

extern int
API_getDescriptor(IIAPI_QUERYPARM *queryP,IIAPI_GETDESCRPARM *getDescrP);

extern void
API_getColumns(IIAPI_GETDESCRPARM *getDescrP,IIAPI_GETCOLPARM *getColP,int k);

#endif /* II_QUERY_H */
!!
? fill myquery.c 
!!
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "iiapi.h"
#include "mymisc.h"
#include "myfile.h"
#include "myquery.h"
 
extern void
API_getErrorInfo(II_PTR errorHandle)
{
   IIAPI_GETEINFOPARM geP;
   int i; /* loop index */
 
   geP.ge_errorHandle = errorHandle;
 
        do {
           IIapi_getErrorInfo(&geP);
 
           if (geP.ge_status != IIAPI_ST_SUCCESS)
             break;
 
        switch( geP.ge_type ) {
        case IIAPI_GE_ERROR:
            printf("ERRROR");
            break;
 
        case IIAPI_GE_WARNING:
            printf("WARNING");
            break;
 
        case IIAPI_GE_MESSAGE:
            printf("USER MESSAGE");
            break;
 
        default:
            printf("unknown error type (%d)", geP.ge_type);
        }
 
        printf("    Info: '%s' %d: %s\n", geP.ge_SQLSTATE,
               geP.ge_errorCode, geP.ge_message ?
               geP.ge_message : "NULL");
 
        if (geP.ge_serverInfoAvail) {
            printf("\t=>svr_id_error = %d\n",
                   geP.ge_serverInfo->svr_id_error);
            printf("\t=>svr_local error = %d\n",
                   geP.ge_serverInfo->svr_local_error);
            printf("\t=>svr_id_server = %d\n",
                   geP.ge_serverInfo->svr_id_server);
            printf("\t=>svr_server_type = %d\n",
                   geP.ge_serverInfo->svr_server_type);
            printf("\t=>svr_severity = %s( 0x%x )\n",
                   (geP.ge_serverInfo->svr_severity ==
                   IIAPI_SVR_DEFAULT) ? "IIAPI_SVR_DEFAULT" :
                   (geP.ge_serverInfo->svr_severity ==
                   IIAPI_SVR_MESSAGE) ? "IIAPI_SVR_MESSAGE" :
                   (geP.ge_serverInfo->svr_severity ==
                   IIAPI_SVR_WARNING) ? "IIAPI_SVR_WARNING" :
                   (geP.ge_serverInfo->svr_severity ==
                   IIAPI_SVR_FORMATTED) ? "IIAPI_SVR_FORMATTED" :
                   "(unknown)", geP.ge_serverInfo->svr_severity);
 
            for (i = 0; i < geP.ge_serverInfo->svr_parmCount; i++) {
                printf("\t: ");
 
                if (geP.ge_serverInfo->svr_parmDescr[i].ds_columnName &&
                    *geP.ge_serverInfo->svr_parmDescr[i].ds_columnName)
                    printf("%s = ",
                    geP.ge_serverInfo->svr_parmDescr[i].ds_columnName);
 
                if (geP.ge_serverInfo->svr_parmDescr[i].ds_nullable  &&
                    geP.ge_serverInfo->svr_parmValue[i].dv_null )
                    printf("NULL");
                else {
                    switch(geP.ge_serverInfo->svr_parmDescr[i].ds_dataType) {
                    case IIAPI_CHA_TYPE:
                        printf("'%*.*s'",
                        geP.ge_serverInfo->svr_parmValue[i].dv_length,
                        geP.ge_serverInfo->svr_parmValue[i].dv_length,
                        (char *)geP.ge_serverInfo->svr_parmValue[i].dv_value);
                        break;
 
                    default:
                        printf("Datatype %d not displayed",
                        geP.ge_serverInfo->svr_parmDescr[i].ds_dataType);
                        break;
                    }
                }
                printf( "\n" );
            }
        }
    } while( 1 );
 
    return;
}

extern void
API_query(IIAPI_CONNPARM *connP, IIAPI_QUERYPARM *queryP)
{
   queryP->qy_connHandle = connP->co_connHandle;
   queryP->qy_tranHandle = connP->co_tranHandle;
 
   printf("Executing query ...\n");
   IIapi_query(queryP);
 
#ifndef _ASC_
    /* sychronous version */
    API_wait(&(queryP->qy_genParm));
#endif
 
     return;
}

extern void
API_getQueryInfo(IIAPI_QUERYPARM *queryP)
{
   IIAPI_GETQINFOPARM getQInfoP;
 
   getQInfoP.gq_genParm.gp_callback = NULL;
   getQInfoP.gq_genParm.gp_closure = NULL;
   getQInfoP.gq_stmtHandle = queryP->qy_stmtHandle;
   printf("Getting query information ...\n");
   IIapi_getQueryInfo(&getQInfoP);
 
#ifndef _ASC_
    /* sychronous version */
    API_wait(&getQInfoP.gq_genParm);
#endif
 
    if (getQInfoP.gq_flags & IIAPI_GQF_FAIL)
        printf("\t=>flag = IIAPI_GQF_FAIL\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_ALL_UPDATED)
        printf("\t=>flag = IIAPI_GQF_ALL_UPDATED\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_NULLS_REMOVED)
        printf("\t=>flag = IIAPI_GQF_NULLS_REMOVED\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_UNKNOWN_REPEAT_QUERY)
        printf("\t=>flag = IIAPI_GQF_UNKNOWN_REPEAT_QUERY\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_END_OF_DATA)
        printf("\t=>flag = IIAPI_GQF_END_OF_DATA\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_CONTINUE)
        printf("\t=>flag = IIAPI_GQF_CONTINUE\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_INVALID_STATEMENT)
        printf("\t=>flag = IIAPI_GQF_INVALID_STATEMENT\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_TRANSACTION_INACTIVE)
        printf("\t=>flag = IIAPI_GQF_TRANSACTION_INACTIVE\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_OBJECT_KEY)
        printf("\t=>flag = IIAPI_GQF_OBJECT_KEY\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_TABLE_KEY)
        printf("\t=>flag = IIAPI_GQF_TABLE_KEY\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_NEW_EFFECTIVE_USER)
        printf("\t=>flag = IIAPI_GQF_NEW_EFFECTIVE_USER\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_FLUSH_QUERY_ID)
        printf("\t=>flag = IIAPI_GQF_FLUSH_QUERY_ID\n");
 
    if (getQInfoP.gq_flags & IIAPI_GQF_ILLEGAL_XACT_STMT)
        printf("\t=>flag = IIAPI_GQF_ILLEGAL_XACT_STMT\n");
 
    if (getQInfoP.gq_mask & IIAPI_GQ_ROW_COUNT)
        printf("\t=>row count = %d\n", getQInfoP.gq_rowCount);
 
    if (getQInfoP.gq_mask & IIAPI_GQ_CURSOR)
        printf("\t=>readonly = TRUE\n");
    else
        printf("\t=>readonly = FALSE\n");
 
    if (getQInfoP.gq_mask & IIAPI_GQ_PROCEDURE_RET)
        printf("\t=>procedure return = %d\n",
                getQInfoP.gq_procedureReturn);
 
    if (getQInfoP.gq_mask & IIAPI_GQ_PROCEDURE_ID)
        printf("\t=>procedure handle = 0x%x\n",
                getQInfoP.gq_procedureHandle);
 
    if (getQInfoP.gq_mask & IIAPI_GQ_REPEAT_QUERY_ID)
        printf("\t=>repeat query ID = 0x%x\n",
                getQInfoP.gq_repeatQueryHandle);
 
    if (getQInfoP.gq_mask & IIAPI_GQ_TABLE_KEY)
        printf("\t=>table key        = %s\n", getQInfoP.gq_tableKey);
 
    if (getQInfoP.gq_mask & IIAPI_GQ_OBJECT_KEY)
        printf("\t=>object key       = %s\n", getQInfoP.gq_objectKey);
 
    return;
}
 
extern void
API_close(IIAPI_QUERYPARM *queryP)
{
    IIAPI_CLOSEPARM closeP;
 
    closeP.cl_genParm.gp_callback = NULL;
    closeP.cl_genParm.gp_closure = NULL;
    closeP.cl_stmtHandle = queryP->qy_stmtHandle;
 
    printf("Closing query proccessing ...\n");
    IIapi_close(&closeP);
#ifndef _ASC_
    /* sychronous version */
    API_wait(&closeP.cl_genParm);
#endif
 
    return;
}

extern void
API_getCopyMap(IIAPI_GETCOPYMAPPARM *iiapi_getcopymapparm, IIAPI_QUERYPARM *queryP-
)
{
   IIAPI_DESCRIPTOR *iiapi_descriptor;
   IIAPI_FDATADESCR *iiapi_fdatadescr;
   int i;

   iiapi_getcopymapparm->gm_genParm.gp_callback = NULL;
   iiapi_getcopymapparm->gm_genParm.gp_closure = NULL;
   iiapi_getcopymapparm->gm_stmtHandle = queryP->qy_stmtHandle;

   IIapi_getCopyMap(iiapi_getcopymapparm);

#ifndef _ASC_
    /* sychronous version */
    API_wait(&iiapi_getcopymapparm->gm_genParm);
#endif

   if (iiapi_getcopymapparm->gm_copyMap.cp_copyFrom)
      printf("This is a copy from statement.\n");
   else printf("This is a copy into statement.\n");
   printf("The maximum number of errors allowed is:\t %ld\n",
          iiapi_getcopymapparm->gm_copyMap.cp_errorCount);
   printf("The name of copy file is :\t%s\n",
          iiapi_getcopymapparm->gm_copyMap.cp_fileName);
   printf("The name of the log file is:\t%s\n",
          iiapi_getcopymapparm->gm_copyMap.cp_logName);
   printf("The number of columns in a row is:\t%d\n",
          iiapi_getcopymapparm->gm_copyMap.cp_dbmsCount);
/*
   iiapi_descriptor = (IIAPI_DESCRIPTOR *)malloc(sizeof(IIAPI_DESCRIPTOR));
   iiapi_fdatadescr = (IIAPI_FDATADESCR *)malloc(sizeof(IIAPI_FDATADESCR));
*/
   iiapi_descriptor = 
	     iiapi_getcopymapparm->gm_copyMap.cp_dbmsDescr;
   iiapi_fdatadescr = 
	     iiapi_getcopymapparm->gm_copyMap.cp_fileDescr;

   for (i=0; i<iiapi_getcopymapparm->gm_copyMap.cp_dbmsCount; i++) 
   {
      display_descriptor(iiapi_descriptor,0);
      printf("*************************************\n");
      display_fdatadescr(iiapi_fdatadescr);
      iiapi_descriptor++;
      iiapi_fdatadescr++;
   }

   return;
}

extern void
API_putColumns(IIAPI_GETCOPYMAPPARM *iiapi_get, IIAPI_QUERYPARM *queryParm)
{
   IIAPI_PUTCOLPARM columnP;
   IIAPI_DATAVALUE         *iiapi_datavalue;
   IIAPI_WAITPARM waitP;
   int i,j,k,number;
   FILE *fp;
   char *input,buffer[80]={'\0'},temp[80]={'\0'};

   waitP.wt_timeout = -1;
   columnP.pc_genParm.gp_callback = NULL;
   columnP.pc_genParm.gp_closure = NULL;
   columnP.pc_stmtHandle = queryParm->qy_stmtHandle;
   columnP.pc_columnCount = iiapi_get->gm_copyMap.cp_dbmsCount;
   columnP.pc_columnData  = iiapi_datavalue =
      (IIAPI_DATAVALUE *)malloc(sizeof(IIAPI_DATAVALUE)*columnP.pc_columnCount);
   columnP.pc_moreSegments = FALSE;

   input = (char *)malloc(80);

   fp = fopen(iiapi_get->gm_copyMap.cp_fileName,"r");
      while(fgets(input,80,fp) !=NULL) {
         i=0;
         j=0;

	 for (k=0;k<80;k++)
	      buffer[k] = ' ';

	 if (*input != '\n') {
	    while (*input != '\n') {
	       if (*input == ' '){ 
		     input++;
	       } 
	       else if (*input != '\t') {
		  buffer[i]=*input;
		  i++;
               } /* end of if */
	       else {
		   if (j==0) {
		      iiapi_datavalue->dv_value = (int *)malloc(sizeof(int));
		      *(int *)iiapi_datavalue->dv_value = atoi(buffer);  
		      iiapi_datavalue->dv_length = 4;
		      }
/*		   iiapi_datavalue->pc_moreSegments = FALSE; */
		   iiapi_datavalue->dv_null = FALSE;
		   iiapi_datavalue++;
		   j++;

          	   for (k=0;k<80;k++)
		      buffer[k] = ' ';

		   i =0;
                   } /* end of else */
	       input++;

            } /* end of while */

	    if ((j !=0 )&& (*input == '\n')) {
	       iiapi_datavalue->dv_length = 7;
	       iiapi_datavalue->dv_value = buffer;
/*	       iiapi_datavalue->pc_moreSegments = FALSE;   */
	       iiapi_datavalue->dv_null = FALSE;
	       } /* end of if */
         } /* end of if */

         IIapi_putColumns(&columnP);  

	 while (!columnP.pc_genParm.gp_completed)
	    IIapi_wait(&waitP);

      } /* end of while */
   fclose(fp);
   return;
}

extern int
API_getDescriptor(IIAPI_QUERYPARM *queryP,IIAPI_GETDESCRPARM *getDescrP)
{
    getDescrP->gd_genParm.gp_callback = NULL;
    getDescrP->gd_genParm.gp_closure = NULL;
    getDescrP->gd_stmtHandle = queryP->qy_stmtHandle;
/*    getDescrP.gd_descriptorCount = 0;
    getDescrP.gd_descriptor = NULL;
*/
    printf("Getting descriptor ...\n");
    IIapi_getDescriptor(getDescrP);
#ifndef _ASC_
    /* sychronous version */
    API_wait(&getDescrP->gd_genParm);
#endif
 
    return(getDescrP->gd_descriptorCount);
}

extern void
API_getColumns(IIAPI_GETDESCRPARM *getDescrP,IIAPI_GETCOLPARM *getColP,int k)
{
    int i,j,idx,l;
    char syc_buffer[128];
 
    getColP->gc_genParm.gp_callback = NULL;
    getColP->gc_genParm.gp_closure = NULL;
 
    getColP->gc_rowCount = 1;
    getColP->gc_columnCount = k;
    l=getColP->gc_rowCount * getColP->gc_columnCount;
    getColP->gc_columnData = ( IIAPI_DATAVALUE * ) malloc (
                              sizeof( IIAPI_DATAVALUE ) * l);
 
    for (j=0,  idx=0; j <getColP->gc_rowCount; j++)
       for (i=0; i<getColP->gc_columnCount; i++,idx++)
       {
          getColP->gc_columnData[idx].dv_value= ( II_PTR )
                                malloc (getDescrP->gd_descriptor[i].ds_length);
       }
    getColP->gc_stmtHandle = getDescrP->gd_stmtHandle;
 
    printf("Getting columns data ...\n");
 
    while (1) {
       IIapi_getColumns(getColP);
 
   #ifndef _ASC_
       /* synchronous version */
       API_wait(&getColP->gc_genParm);
   #endif
 
      if (getColP->gc_genParm.gp_status == IIAPI_ST_NO_DATA )
         break;
 
      printf("=========================================\n");
 
      for (i=0;i<getColP->gc_rowsReturned; i++)
      {
         for (j=0;j<getDescrP->gd_descriptorCount;j++)
         {
            printf("%s =",getDescrP->gd_descriptor[j].ds_columnName?
                          getDescrP->gd_descriptor[j].ds_columnName: "(unknown)"
);
           IIsyc_printData(&getDescrP->gd_descriptor[j],
                           &getColP->gc_columnData[i*getDescrP->gd_descriptorCount+j-
],syc_buffer);
           printf("%s\n",syc_buffer);
        }
     printf("========================================\n");
     }
   }
   return;
}
!!
? fill mysession.h 
!!
#ifndef II_SESSION_H
#define II_SESSION_H

extern void
API_connect(IIAPI_CONNPARM *connP);

extern void
API_disconnect(IIAPI_CONNPARM *connP);

#endif /* II_SESSION_H */

!!
? fill mysession.c 
!!
#include <stdio.h>
#include <string.h>
#include "iiapi.h"
#include "mymisc.h"
#include "mysession.h"

extern void
API_connect(IIAPI_CONNPARM *connP)
{
   connP->co_genParm.gp_callback = NULL;
   connP->co_genParm.gp_closure = NULL;
   connP->co_username = NULL;
   connP->co_password = NULL;
   connP->co_timeout = -1;
   connP->co_tranHandle = ( II_PTR ) NULL;
   connP->co_type = IIAPI_CT_SQL;

   printf("Establishing connection ... \n");
   IIapi_connect(connP);

   #ifndef _ASC_
    /* sychronous version */
    API_wait(&connP->co_genParm);
   #endif
 
    return;
}

extern void
API_disconnect(IIAPI_CONNPARM *connP)
{
    IIAPI_DISCONNPARM disconnP;
 
    disconnP.dc_genParm.gp_callback = NULL;
    disconnP.dc_genParm.gp_closure = NULL;
 
    /* disconnect the connected */
    disconnP.dc_connHandle = connP->co_connHandle;
 
    printf("Disconnecting ...\n");
    IIapi_disconnect(&disconnP);
 
#ifndef _ASC_
    /* sychronous version */
    API_wait(&disconnP.dc_genParm);
#endif
 
    return;
}

!!
? fill mytran.c 
!!
#include <stdio.h>
#include <string.h>
#include "iiapi.h"
#include "mymisc.h"
#include "mytran.h"
 
extern void
API_commit(IIAPI_QUERYPARM *queryP)
{
    IIAPI_COMMITPARM commitP;
 
    commitP.cm_genParm.gp_callback = NULL;
    commitP.cm_genParm.gp_closure = NULL;
 
    commitP.cm_tranHandle = queryP->qy_tranHandle;
 
    printf("Commiting a transaction ...\n");
    IIapi_commit(&commitP);
 
#ifndef _ASC_
    /* synchronous version */
    API_wait(&commitP.cm_genParm);
#endif

    queryP->qy_tranHandle = NULL;
 
    return;
}
!!
? fill mytran.h 
!!
#ifndef II_TRAN_H
#define II_TRAN_H
 
extern void
API_commit(IIAPI_QUERYPARM *queryP);
 
#endif /* II_TRAN_H */
!!
? sepcc myaccess myfile mymain mymisc myquery mysession mytran 
<<
>>
<< IF (NT_GENERIC)
myaccess.c
myfile.c
mymain.c
mymisc.c
myquery.c
mysession.c
mytran.c
>>
.if VMS
? seplnk -a mymain myaccess myfile mymisc myquery mysession mytran 
<<
>>
.else
? seplnk mymain myaccess myfile mymisc myquery mysession mytran 
<<
>>
.endif
? run mymain.exe apidb1 
<< 
Initializing API ...
Establishing connection ... 
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing drop table a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_ERROR
ERRROR    Info: '42500' 2753: DROP: 'a' does not exist or is not owned by you.
	=>svr_id_error = 67653632
	=>svr_local error = 2753
	=>svr_id_server = 13974
	=>svr_server_type = 0
	=>svr_severity = IIAPI_SVR_DEFAULT( 0x0 )
	: 'Wed Jan  5 17:04:21 2000 E_US0AC1_2753	DROP: 'a' does not exist or is not owned -
by you.'
	=>flag = IIAPI_GQF_FAIL
	=>flag = IIAPI_GQF_TRANSACTION_INACTIVE
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing create table a (i integer, a char(7) )with page_size=4096
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing copy a (i = c0tab with null('NULL'), a= varchar(0)nl with nul-
l('NULL'), nl= d1) from 'a.tes'
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
This is a copy from statement.
The maximum number of errors allowed is:	 0
The name of copy file is :	a.tes
The name of the log file is:	
The number of columns in a row is:	2
The data type is::	IIAPI_INT_TYPE
Data is nullable or not:	TRUE
The length of the value being described: 4
The usage of the value being described: IIAPI_COL_TUPLE
The column Name is: i
*************************************
The separator between columns: TRUE
The length of the separator:	2
The value of the separator: 	
The allowance of a null value in the column: TRUE
Is null value provide: TRUE
The data type is::	IIAPI_CHR_TYPE
Data is nullable or not:	FALSE
The length of the value being described: 4
The usage of the value being described: IIAPI_COL_TUPLE
Whether the value is null : 0 
The length of null symbole: 4
The value of the null: NULL

The data type is::	IIAPI_CHA_TYPE
Data is nullable or not:	TRUE
The length of the value being described: 7
The usage of the value being described: IIAPI_COL_TUPLE
The column Name is: a
*************************************
The separator between columns: TRUE
The length of the separator:	2
The value of the separator: 

The allowance of a null value in the column: TRUE
Is null value provide: TRUE
The data type is::	IIAPI_VCH_TYPE
Data is nullable or not:	FALSE
The length of the value being described: 6
The usage of the value being described: IIAPI_COL_TUPLE
Whether the value is null : 0 
The length of null symbole: 6
The value of the null: NULL

Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>row count = 1
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing select * from a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting descriptor ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting columns data ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
=========================================
i =2
a ="5bbbbb "
========================================
Synchronizing ...
	=>gp_status: IIAPI_ST_NO_DATA
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>row count = 1
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing drop table a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Disconnecting ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Releasing API environment...
Successfully, released API environment
Shutting down API ...
>>
<< IF (NT_GENERIC) 
Initializing API ...
Establishing connection ... 
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing drop table a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_ERROR
ERRROR    Info: '42500' 2753: DROP: 'a' does not exist or is not owned by you.
	=>svr_id_error = 67653632
	=>svr_local error = 2753
	=>svr_id_server = 258
	=>svr_server_type = 0
	=>svr_severity = IIAPI_SVR_DEFAULT( 0x0 )
	: 'Wed Jan 05 15:19:30 2000 E_US0AC1_2753	DROP: 'a' does not exist or is not owned -
by you.'
	=>flag = IIAPI_GQF_FAIL
	=>flag = IIAPI_GQF_TRANSACTION_INACTIVE
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing create table a (i integer, a char(7) )with page_size=4096
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing copy a (i = c0tab with null('NULL'), a= varchar(0)nl with nul-
l('NULL'), nl= d1) from 'a.tes'
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
This is a copy from statement.
The maximum number of errors allowed is:	 0
The name of copy file is :	a.tes
The name of the log file is:	
The number of columns in a row is:	2
The data type is::	IIAPI_INT_TYPE
Data is nullable or not:	TRUE
The length of the value being described: 4
The usage of the value being described: IIAPI_COL_TUPLE
The column Name is: i
*************************************
The separator between columns: TRUE
The length of the separator:	2
The value of the separator: 	
The allowance of a null value in the column: TRUE
Is null value provide: TRUE
The data type is::	IIAPI_CHR_TYPE
Data is nullable or not:	FALSE
The length of the value being described: 4
The usage of the value being described: IIAPI_COL_TUPLE
Whether the value is null : 0 
The length of null symbole: 4
The value of the null: NULL

The data type is::	IIAPI_CHA_TYPE
Data is nullable or not:	TRUE
The length of the value being described: 7
The usage of the value being described: IIAPI_COL_TUPLE
The column Name is: a
*************************************
The separator between columns: TRUE
The length of the separator:	2
The value of the separator: 

The allowance of a null value in the column: TRUE
Is null value provide: TRUE
The data type is::	IIAPI_VCH_TYPE
Data is nullable or not:	FALSE
The length of the value being described: 6
The usage of the value being described: IIAPI_COL_TUPLE
Whether the value is null : 0 
The length of null symbole: 6
The value of the null: NULL

Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>row count = 1
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing select * from a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting descriptor ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting columns data ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
=========================================
i =2
a ="5bbbbb "
========================================
Synchronizing ...
	=>gp_status: IIAPI_ST_NO_DATA
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>row count = 1
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Now, database is doing drop table a
Executing query ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Getting query information ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
	=>readonly = FALSE
Closing query proccessing ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Commiting a transaction ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Disconnecting ...
Synchronizing ...
	=>gp_status: IIAPI_ST_SUCCESS
Releasing API environment...
Successfully, released API environment
Shutting down API ...
>>
? delete mymain.exe 
<<
~
>>
? delete mymain.obj 
<<
~
>>
? delete myaccess.obj 
<<
~
>>
? delete myfile.obj 
<<
~
>>
? delete mymisc.obj 
<<
~
>>
? delete myquery.obj 
<<
~
>>
? delete mysession.obj 
<<
~
>>
? delete mytran.obj 
<<
~
>>
? delete mymain.o 
<<
~
>>
? delete myaccess.o 
<<
~
>>
? delete myfile.o 
<<
~
>>
? delete mymisc.o 
<<
~
>>
? delete myquery.o 
<<
~
>>
? delete mysession.o 
<<
~
>>
? delete mytran.o 
<<
~
>>
? delete iiapi.h 
<<
~
>>
? delete iiapi.tmp 
<<
~
>>
? delete iiapidep.h 
<<
~
>>


Ending at: Wed Jan  5 17:04:49 2000
