/*
	Copyright (c) 2009 Ingres Corporation

	Test Name: api07.sep
	Time: Thu Mar 27 11:38:32 1997
	User Name: testenv
	Terminal type: septerm
 
	Test ID : api07.sep
	Module  : be/lar
	Filename: api07.sep
	Purpose	: To test API in Asynchronous: IIapi_registerXID()
		  IIapi_releaseXID(),IIapi_prepareCommit()
	Input Files  :
	Output Files :
	Database     :
	Tables       :
	Synopsis     :

 History: 27-Mar-1997	zhaqi01		Created
	  23-Jul-1997	chegu01		added the VMS version.
	  29-sep-1998   (kinte01)       For VMS use seplnk -a to pick up the
					API shared library otherwise the
					executable would be linked as an
					ESQLC application
	  29-sep-1998   (kinte01)       Changed size advise value for VMS to
					4120 which is the new value in 2.0
          08-dec-1998   (hanch04)       Changed size advise value to
                                        4064  which is the new value in 2.5
	  17-Mar-1999	(vande02)	hard-coded VPG_SZ to 8K
	2-Arp-1999      (yu$pe02)       Hard code to 2K.

          19-May-1999	(somsa01)	Added alternate canon.
          07-sep-1999   (madsu02)
		x-integrated from handoffqa into main. There is a conflict in
		the page-size. Yu$pe02 didn't hard code the page-size to 2k
		instead it was 8k.
          30-Dec-1999	(ngutr03)
		Changed initP.in_version from IIAPI_VERSION_1 to 
		IIAPI_VERSION_2 (see syc_2phase.c).  Added new member variable
		in_envHandle to initP structure (syc_2phase.c).  Added new API
		function IIapi_releaseEnv() to synchronous.c to release the
		environment handle.
	11-jun-2003 (abbjo03)
		Corrections to eliminate warnings on VMS.
	 6-Oct-2006	(rogch01)
		Reorder canons to make the platform specific ones diff against
		the result to make interpretation easier.  Change size advise
		in line with Windows for VMS.
	09-Apr-2009	(boija02)
		Won't work on cluster, no 2-phase-commit.
	23-Feb-2010 (kschendel)
		Don't display sizeAdvise if it looks OK.
*/
.if (SEPPARAM_CLUSTER)
? echo No two phase commit on cluster, amend if that changes.
<<
No two phase commit on cluster, amend if that changes.
>>
.else
? fill header.h 
!!
/*
** Name: header.h	Header file used by test programs of API functions
**
** Description:		Contains function prototypes for synchronous and
**			asynchronous mode testing.
**
** History:
**      15-May-95 (Manfu)
**	   creation
**
*/

#include <stdio.h>
#include "iiapi.h"
#include "iiapidep.h"

#define DBname		"usilhu09::apidb" /* Database used for testing */
#define DBA		"testenv"
#define CONNTIMEOUT	-1	/* Timeout not desired for connection */
#define WAITTIMEOUT	10	/* 10 milliseconds for wait timeout */

/*
** Name: Handleparm
**
** Description: This datatype defines the function pointers for
**		the various handles.
**
*/

typedef struct Handleparm {
	II_PTR	hp_connHandle;
	II_PTR	hp_tranHandle;
	II_PTR	hp_stmtHandle;
	II_VOID	(*hp_next)();
} Handleparm;

/*	Function prototypes for synchronous mode testing     */
/*							     */
void syc_initialize	(IIAPI_INITPARM *);
void syc_releaseEnv     ( II_PTR );
void syc_terminate	(IIAPI_TERMPARM *);
void syc_connect	(Handleparm *, IIAPI_CONNPARM *);
void syc_disconnect	(Handleparm *, IIAPI_DISCONNPARM *);
void syc_setConnectParam(Handleparm *, IIAPI_SETCONPRMPARM *);
void syc_modifyConnect	(Handleparm *, IIAPI_MODCONNPARM *);
void syc_query		(Handleparm *, IIAPI_QUERYPARM *);
void syc_close		(Handleparm *, IIAPI_CLOSEPARM *);
void syc_cancel		(Handleparm *, IIAPI_CANCELPARM *);
void syc_registerXID	(IIAPI_REGXIDPARM *);
void syc_releaseXID	(IIAPI_RELXIDPARM *);
void syc_prepareCommit	(Handleparm *, IIAPI_PREPCMTPARM *);
void syc_commit		(Handleparm *, IIAPI_COMMITPARM *);
void syc_rollback	(Handleparm *, IIAPI_ROLLBACKPARM *);
void syc_savePoint	(Handleparm *, IIAPI_SAVEPTPARM *);
void syc_convertData	(IIAPI_DESCRIPTOR, IIAPI_DATAVALUE,
			 IIAPI_DESCRIPTOR, IIAPI_DATAVALUE *);
void syc_setDescriptor	(Handleparm *, IIAPI_SETDESCRPARM *);
void syc_getDescriptor	(Handleparm *, IIAPI_GETDESCRPARM *);
void syc_putParms	(Handleparm *, IIAPI_PUTPARMPARM *);
void syc_getColumns	(Handleparm *, IIAPI_GETCOLPARM *, IIAPI_DESCRIPTOR *);
void syc_getCopyMap	(Handleparm *, IIAPI_GETCOPYMAPPARM *);
void syc_getQueryInfo	(Handleparm *, IIAPI_GETQINFOPARM *);
void syc_getErrorInfo	(II_PTR);

/* This function returns the status of completion of each API function */
/* in the code */
char *check_status	(int);

/* Function prototypes for asynchronous mode testing */
/*						     */
#define asc_initialize	syc_initialize
#define asc_terminate	syc_terminate
void asc_connect	(Handleparm *, IIAPI_CONNPARM *);
void asc_disconnect	(Handleparm *, IIAPI_DISCONNPARM *);
void asc_setConnectParam(Handleparm *, IIAPI_SETCONPRMPARM *);
void asc_modifyConnect	(Handleparm *, IIAPI_MODCONNPARM *);
void asc_query		(Handleparm *, IIAPI_QUERYPARM *);
void asc_close		(Handleparm *, IIAPI_CLOSEPARM *);
void asc_cancel		(Handleparm *, IIAPI_CANCELPARM *);
#define asc_registerXID	syc_registerXID
#define asc_releaseXID	syc_releaseXID
void asc_prepareCommit	(Handleparm *, IIAPI_PREPCMTPARM *);
void asc_commit		(Handleparm *, IIAPI_COMMITPARM *);
void asc_rollback	(Handleparm *, IIAPI_ROLLBACKPARM *);
void asc_savePoint	(Handleparm *, IIAPI_SAVEPTPARM *);
#define asc_convertData	syc_convertData
void asc_setDescriptor	(Handleparm *, IIAPI_SETDESCRPARM *);
void asc_getDescriptor	(Handleparm *, IIAPI_GETDESCRPARM *);
void asc_putParms	(Handleparm *, IIAPI_PUTPARMPARM *);
void asc_getColumns	(Handleparm *, IIAPI_GETCOLPARM *, IIAPI_DESCRIPTOR *);
void asc_getCopyMap	(Handleparm *, IIAPI_GETCOPYMAPPARM *);
void asc_getQueryInfo	(Handleparm *, IIAPI_GETQINFOPARM *);
#define asc_getErrorInfo syc_getErrorInfo

extern int space, lspace;
#define BEGIN(x)\
        for (space=0; space<lspace; space++, printf("----"));\
        lspace++;\
        printf(" BEGIN %s\n", x);
#define END(x)\
        lspace--;\
        for (space=0; space<lspace; space++, printf("----"));\
        printf(" END   %s\n", x);
!!
? cp @file(ii_system,ingres,files,iiapidep.h) iiapidep.h 
<<

>>
? cp @file(ii_system,ingres,files,iiapi.h) iiapi.tmp 
<<

>>
.if (NT_GENERIC) 
? fill makeiiapi.bat 
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h
!!
? run makeiiapi.bat 
<<

>>
.endif 
.if (UNIX) 
? fill makeiiapi.sh 
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h
!!
? sh makeiiapi.sh 
<<

>>
.endif 
.if (VMS) 
? fill iiapi_edit.com
!!
$ pipe sed "s/<iiapidep.h>/""iiapidep.h""/g" iiapi.tmp > iiapi.h
!!
? qasetuser testenv @iiapi_edit.com
<<
>>
.endif 
? fill myfile.h 
!!
#ifndef II_FILE_H
#define II_FILE_H

extern  void
IIsyc_free( II_PTR buffer );
 
extern  II_PTR
IIsyc_malloc( int size );
 
extern  char*
IIsyc_stalloc( char *src );
 
extern  char*
IIsyc_printData(IIAPI_DESCRIPTOR *descriptor,IIAPI_DATAVALUE *dataValue,char *buffer-
 );

#endif /* II_QUERY_H */
!!
? fill myfile.c 
!!
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "iiapi.h"
#include "myfile.h"

static void syc_formatString(char *string,int length,char *buffer);

extern  char*
IIsyc_stalloc( char     *src )
{
    char            *dest;
 
    dest = ( char * )IIsyc_malloc( strlen( src ) + 1 );
    strcpy( dest, src );
 
    return      ( dest );
}

extern  II_PTR
IIsyc_malloc( int       size )
{
    II_PTR          retValue;
 
    if ( ! ( retValue = ( II_PTR )malloc( size ) ) )
    {
        II_printf( "ERROR: cann't allocate size %d\n", size );
 
        exit( 0 );
    }
 
    return      ( retValue );
}

extern  void
IIsyc_free( II_PTR      buffer )
{
    free( buffer );
 
    return;
}

extern  char*
IIsyc_printData( IIAPI_DESCRIPTOR       *descriptor,
                 IIAPI_DATAVALUE        *dataValue,
                 char                   *buffer )
{
    IIAPI_CONVERTPARM   cv;
    char                *buf = buffer;
    int                 i;
    II_INT2             length;
    II_FLOAT4           *float4;
    II_FLOAT8           *float8;
    II_INT1             *integer1;
    II_INT2             *integer2;
    II_INT4             *integer4;
 
    if ( dataValue->dv_null )
    {
        II_sprintf( buffer, "( NULL )" );
        return ( buffer );
    }
 
    switch( abs( descriptor->ds_dataType ) )
    {
        case IIAPI_LOGKEY_TYPE:
        case IIAPI_TABKEY_TYPE:
            for( i = 0; i<dataValue->dv_length; i++ )
            {
                char c, d;
 
                c = ( ( II_CHAR * ) dataValue->dv_value )[i];
                d = ( c >> 4 ) & 0x0f;
                *buf++ = ( d < 10 ) ? d + '0' : (d - 10) + 'A';
                d = c & 0x0f;
                *buf++ = ( d < 10 ) ? d + '0' : (d - 10) + 'A';
                *buf++ = ' ';
            }
            *buf = '\0';
            break;
 
        case IIAPI_LBYTE_TYPE:
        case IIAPI_LTXT_TYPE:
        case IIAPI_LVCH_TYPE:
        case IIAPI_TXT_TYPE:
        case IIAPI_VBYTE_TYPE:
        case IIAPI_VCH_TYPE:
            memcpy( &length, dataValue->dv_value, sizeof( length ) );
            syc_formatString( (char *)dataValue->dv_value + sizeof( length ),
                              (int)length, buffer );
            break;
 
        case IIAPI_BYTE_TYPE:
        case IIAPI_CHA_TYPE:
        case IIAPI_CHR_TYPE:
            syc_formatString( (char *)dataValue->dv_value,
                              (int)dataValue->dv_length, buffer );
            break;
 
        case IIAPI_FLT_TYPE:
            switch( dataValue->dv_length )
            {
                case 4:
                    float4 = (II_FLOAT4 *)dataValue->dv_value;
                    II_sprintf( buffer, "%f", (II_FLOAT8)*float4 );
                    break;
 
                case 8:
                    float8 = (II_FLOAT8 *)dataValue->dv_value;
                    II_sprintf( buffer, "%f", *float8 );
                    break;
 
                default:
                    II_sprintf( buffer, "invalid float length" );
                    break;
            }
            break;
 
        case IIAPI_INT_TYPE:
            switch( dataValue->dv_length )
            {
                case 1:
                    integer1 = (II_INT1 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer1 );
                    break;
 
                case 2:
                    integer2 = (II_INT2 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer2 );
                    break;
 
                case 4:
                    integer4 = (II_INT4 *)dataValue->dv_value;
                    II_sprintf( buffer, "%ld", (long)*integer4 );
                    break;
 
                default:
                    II_sprintf( buffer, "invalid integer length" );
                    break;
            }
            break;
 
        case IIAPI_DTE_TYPE:
        case IIAPI_DEC_TYPE:
        case IIAPI_MNY_TYPE:
            cv.cv_srcDesc.ds_dataType = descriptor->ds_dataType;
            cv.cv_srcDesc.ds_nullable = descriptor->ds_nullable;
            cv.cv_srcDesc.ds_length = descriptor->ds_length;
            cv.cv_srcDesc.ds_precision = descriptor->ds_precision;
            cv.cv_srcDesc.ds_scale = descriptor->ds_scale;
            cv.cv_srcDesc.ds_columnType = descriptor->ds_columnType;
            cv.cv_srcDesc.ds_columnName = descriptor->ds_columnName;
 
            cv.cv_srcValue.dv_null = dataValue->dv_null;
            cv.cv_srcValue.dv_length = dataValue->dv_length;
            cv.cv_srcValue.dv_value = dataValue->dv_value;
 
            cv.cv_dstDesc.ds_dataType = IIAPI_CHA_TYPE;
            cv.cv_dstDesc.ds_nullable = FALSE;
            cv.cv_dstDesc.ds_length = 32;
            cv.cv_dstDesc.ds_precision = 0;
            cv.cv_dstDesc.ds_scale = 0;
            cv.cv_dstDesc.ds_columnType = IIAPI_COL_TUPLE;
            cv.cv_dstDesc.ds_columnName = NULL;
 
            cv.cv_dstValue.dv_null = FALSE;
            cv.cv_dstValue.dv_length = cv.cv_dstDesc.ds_length;
            cv.cv_dstValue.dv_value = buffer;
 
            IIapi_convertData( &cv );
 
            if ( cv.cv_status != IIAPI_ST_SUCCESS )
            {
                II_sprintf( buffer, "(invalid type)" );
                break;
            }
 
            buffer[ cv.cv_dstValue.dv_length ] = '\0';
            break;
 
        default:
            II_sprintf( buffer, "invalid type" );
            break;
    }
 
    return( buffer );
}

static void
syc_formatString( char          *string,
                  int           length,
                  char          *buffer )
{
    int i, j;
 
    if ( length > 72 )  *buffer++ = '\n';
    *buffer++ = '"';
 
    for ( j = 72; length > 0; length--, string++, j-- )
    {
        if ( ! j )
        {
            *buffer++ = '"';
            *buffer++ = '\n';
            *buffer++ = '"';
            j = 72;
        }
 
        if ( isprint( *string ) )
            *buffer++ = *string;
        else
        {
            II_sprintf( buffer, "\\%03.03d", *string );
            buffer += 4;
        }
    }
 
    *buffer++ = '"';
    *buffer = '\0';
}
!!
? fill synchronous.c 
!!
/*
** Name: synchronous.c
**
** Description: This file contains the API functions for
**		synchronous mode. This file is used as an
**		include file by all programs in synchronous mode.
**
** History:
**	15-May-95 (Manfu)
**         creation
**		
*/

#include "header.h"


void syc_initialize(IIAPI_INITPARM *iiapi_initparm)
{
	IIapi_initialize(iiapi_initparm);
	printf("IIapi_initialize return status:\t%s\n",
		check_status(iiapi_initparm->in_status));
	return;
}

void syc_releaseEnv( II_PTR envHandle )
{
	IIAPI_RELENVPARM relEnvParm;

	relEnvParm.re_envHandle = envHandle;
	printf("Releasing API environment...\n");
	IIapi_releaseEnv(&relEnvParm);
	printf("%s\n", (relEnvParm.re_status == IIAPI_ST_SUCCESS) ? "Successfully, released-
 API environment" : "Failed to release API environment");
}

void syc_terminate(IIAPI_TERMPARM *iiapi_termparm)
{
	IIapi_terminate(iiapi_termparm);
	printf("IIapi_terminate return status:\t%s\n",
		check_status(iiapi_termparm->tm_status));
	return;
}


void syc_connect(Handleparm     *handleparm,
		 IIAPI_CONNPARM *iiapi_connparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_connparm->co_genParm.gp_callback = NULL;
	iiapi_connparm->co_connHandle = handleparm->hp_connHandle;
	iiapi_connparm->co_tranHandle = handleparm->hp_tranHandle;
        iiapi_connparm->co_type = IIAPI_CT_SQL;

	IIapi_connect(iiapi_connparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_connparm->co_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_connect return status:\t%s\n",
		check_status(iiapi_connparm->co_genParm.gp_status));
	syc_getErrorInfo(iiapi_connparm->co_genParm.gp_errorHandle);
	handleparm->hp_connHandle = iiapi_connparm->co_connHandle;
	handleparm->hp_tranHandle = iiapi_connparm->co_tranHandle;
	if (iiapi_connparm->co_sizeAdvise < 4096)
	{
	    printf("\tsizeAdvise:\t %ld (less than fastselect + gca header?)\n",
		    iiapi_connparm->co_sizeAdvise);
	}
	else if (iiapi_connparm->co_sizeAdvise > 256*1024)
	{
	    printf("\tsizeAdvise:\t %ld (unreasonably large?)\n",
		    iiapi_connparm->co_sizeAdvise);
	}
	else
	{
	    printf("\tsizeAdvise: (looks OK, suppressed)\n");
	}
	printf("\tapiLevel:\t%ld\n", iiapi_connparm->co_apiLevel);
	return;
}


void syc_disconnect(Handleparm        *handleparm,
		    IIAPI_DISCONNPARM *iiapi_disconnparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_disconnparm->dc_genParm.gp_callback = NULL;
	iiapi_disconnparm->dc_connHandle = handleparm->hp_connHandle;
	IIapi_disconnect(iiapi_disconnparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_disconnparm->dc_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_disconnect return status:\t%s\n",
		check_status(iiapi_disconnparm->dc_genParm.gp_status));
	syc_getErrorInfo(iiapi_disconnparm->dc_genParm.gp_errorHandle);
	handleparm->hp_connHandle = NULL;
	return;
}

void syc_query(Handleparm      *handleparm,
	       IIAPI_QUERYPARM *iiapi_queryparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_queryparm->qy_genParm.gp_callback = NULL;
	iiapi_queryparm->qy_connHandle = handleparm->hp_connHandle;
	iiapi_queryparm->qy_tranHandle = handleparm->hp_tranHandle;
	IIapi_query(iiapi_queryparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_queryparm->qy_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("iiapi_query return status:\t%s\n",
		check_status(iiapi_queryparm->qy_genParm.gp_status));
	syc_getErrorInfo(iiapi_queryparm->qy_genParm.gp_errorHandle);
	handleparm->hp_tranHandle = iiapi_queryparm->qy_tranHandle;
	handleparm->hp_stmtHandle = iiapi_queryparm->qy_stmtHandle;
	return;
}


void syc_close(Handleparm      *handleparm,
	       IIAPI_CLOSEPARM *iiapi_closeparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;
	
	iiapi_closeparm->cl_genParm.gp_callback = NULL;
	iiapi_closeparm->cl_stmtHandle = handleparm->hp_stmtHandle;
	IIapi_close(iiapi_closeparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_closeparm->cl_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_close return status:\t%s\n",
		check_status(iiapi_closeparm->cl_genParm.gp_status));
	syc_getErrorInfo(iiapi_closeparm->cl_genParm.gp_errorHandle);
	handleparm->hp_stmtHandle = NULL;
	return;
}

void syc_registerXID(IIAPI_REGXIDPARM *iiapi_regxidparm)
{
	IIapi_registerXID(iiapi_regxidparm);
	printf("IIapi_registerXID return status:\t%s\n",
		check_status(iiapi_regxidparm->rg_status));
	return;
}


void syc_releaseXID(IIAPI_RELXIDPARM *iiapi_relxidparm)
{
	IIapi_releaseXID(iiapi_relxidparm);
	printf("IIapi_releaseXID return status:\t%s\n",
		check_status(iiapi_relxidparm->rl_status));
	return;
}


void syc_prepareCommit(Handleparm        *handleparm,
                       IIAPI_PREPCMTPARM *iiapi_prepcmtparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_prepcmtparm->pr_genParm.gp_callback = NULL;
	iiapi_prepcmtparm->pr_tranHandle = handleparm->hp_tranHandle;
	IIapi_prepareCommit(iiapi_prepcmtparm);
	iiapi_waitparm.wt_timeout = 10;
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_prepcmtparm->pr_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_prepareCommit return status:\t%s\n",
		check_status(iiapi_prepcmtparm->pr_genParm.gp_status));
	syc_getErrorInfo(iiapi_prepcmtparm->pr_genParm.gp_errorHandle);
	handleparm->hp_tranHandle = iiapi_prepcmtparm->pr_tranHandle;
	return;
}


void syc_commit(Handleparm       *handleparm,
		IIAPI_COMMITPARM *iiapi_commitparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_commitparm->cm_genParm.gp_callback = NULL;
	iiapi_commitparm->cm_tranHandle = handleparm->hp_tranHandle;
	IIapi_commit(iiapi_commitparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_commitparm->cm_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_commit return status:\t%s\n",
		check_status(iiapi_commitparm->cm_genParm.gp_status));
	syc_getErrorInfo(iiapi_commitparm->cm_genParm.gp_errorHandle);		
	handleparm->hp_tranHandle = NULL;
	return;
}


void syc_rollback(Handleparm         *handleparm,
                  IIAPI_ROLLBACKPARM *iiapi_rollbackparm)
{
        IIAPI_WAITPARM          iiapi_waitparm;
 
        iiapi_rollbackparm->rb_genParm.gp_callback = NULL;
	iiapi_rollbackparm->rb_tranHandle = handleparm->hp_tranHandle;
        IIapi_rollback(iiapi_rollbackparm);
        iiapi_waitparm.wt_timeout = WAITTIMEOUT;
        while (iiapi_rollbackparm->rb_genParm.gp_completed == FALSE)
                IIapi_wait(&iiapi_waitparm);
        printf("IIapi_rollback return status:\t%s\n",
                check_status(iiapi_rollbackparm->rb_genParm.gp_status));
        syc_getErrorInfo(iiapi_rollbackparm->rb_genParm.gp_errorHandle);
	if (iiapi_rollbackparm->rb_savePointHandle == NULL)
		handleparm->hp_tranHandle = NULL;
        return;
}
 
void syc_getQueryInfo(Handleparm         *handleparm,
                      IIAPI_GETQINFOPARM *iiapi_getqinfoparm)
{
	IIAPI_WAITPARM		iiapi_waitparm;

	iiapi_getqinfoparm->gq_genParm.gp_callback = NULL;
	iiapi_getqinfoparm->gq_stmtHandle = handleparm->hp_stmtHandle;
	IIapi_getQueryInfo(iiapi_getqinfoparm);
	iiapi_waitparm.wt_timeout = WAITTIMEOUT;
	while (iiapi_getqinfoparm->gq_genParm.gp_completed == FALSE)
		IIapi_wait(&iiapi_waitparm);
	printf("IIapi_getQueryInfo return status:\t%s\n",
		check_status(iiapi_getqinfoparm->gq_genParm.gp_status));
	syc_getErrorInfo(iiapi_getqinfoparm->gq_genParm.gp_errorHandle);

	if (iiapi_getqinfoparm->gq_flags)
	{
		printf("\tgq_flags:\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_FAIL)
			printf("\t\t\tIIAPI_GQF_FAIL\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_ALL_UPDATED)
			printf("\t\t\tIIAPI_GQF_ALL_UPDATED\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_NULLS_REMOVED)
			printf("\t\t\tIIAPI_GQF_NULLS_REMOVED\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_UNKNOWN_REPEAT_QUERY)
			printf("\t\t\tIIAPI_GQF_UNKNOWN_REPEAT_QUERY\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_END_OF_DATA)
			printf("\t\t\tIIAPI_GQF_END_OF_DATA\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_CONTINUE)
			printf("\t\t\tIIAPI_GQF_CONTINUE\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_INVALID_STATEMENT)
			printf("\t\t\tIIAPI_GQF_STATEMENT\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_TRANSACTION_INACTIVE)
			printf("\t\t\tIIAPI_GQF_TRANSACTION_INACTIVE\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_OBJECT_KEY)
			printf("\t\t\tIIAPI_GQF_OBJECT_KEY\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_TABLE_KEY)
			printf("\t\t\tIIAPI_GQF_TABLE_KEY\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_NEW_EFFECTIVE_USER)
			printf("\t\t\tIIAPI_GQF_NEW_EFFECTIVE_USER\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_FLUSH_QUERY_ID)
			printf("\t\t\tIIAPI_GQF_FLUSH_QUERY_ID\n");
		if (iiapi_getqinfoparm->gq_flags&IIAPI_GQF_ILLEGAL_XACT_STMT)
			printf("\t\t\tIIAPI_GQF_ILLEGAL_XACT_STMT\n");
	}

	if (!iiapi_getqinfoparm->gq_mask)
		printf("\tNo response data is available\n");
	else
	{
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_ROW_COUNT)
			printf("\tgq_rowCount:\t%ld\n",
				iiapi_getqinfoparm->gq_rowCount);
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_CURSOR)
		{
			printf("\tgq_readonly:\t");
			switch (iiapi_getqinfoparm->gq_readonly)
			{
				case TRUE:
					printf("TRUE");
					break;
				case FALSE:
					printf("FALSE");
					break;
				default:
					printf("Unknown:\t%d",
					iiapi_getqinfoparm->gq_readonly);
				break;
			}
			printf("\n");
		}
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_PROCEDURE_RET)
			printf("\tgq_procedureReturn:\t%ld\n",
				iiapi_getqinfoparm->gq_procedureReturn);
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_PROCEDURE_ID)
			printf("\tgq_procedureHandle:\t%p\n",
				iiapi_getqinfoparm->gq_procedureHandle);
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_REPEAT_QUERY_ID)
			printf("\tgq_repeatQueryHandle:\t%p\n",
				iiapi_getqinfoparm->gq_repeatQueryHandle);
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_TABLE_KEY)
			printf("gq_tableKey:\t%s\n",
				iiapi_getqinfoparm->gq_tableKey);
		if (iiapi_getqinfoparm->gq_mask & IIAPI_GQ_OBJECT_KEY)
			printf("gq_objectKey:\t%s\n",
				iiapi_getqinfoparm->gq_objectKey);
	}

	return;
}

char *check_status(int in_status)
{
	switch (in_status)
        {
                case IIAPI_ST_SUCCESS:
                        return ("IIAPI_ST_SUCCESS");
		case IIAPI_ST_MESSAGE:
			return ("IIAPI_ST_MESSAGE");
		case IIAPI_ST_WARNING:
			return ("IIAPI_ST_WARNING");
		case IIAPI_ST_ERROR:
			return ("IIAPI_ST_ERROR");
		case IIAPI_ST_NO_DATA:
			return ("IIAPI_ST_NO_DATA");
                case IIAPI_ST_FAILURE:
                        return ("IIAPI_ST_FAILURE");
		case IIAPI_ST_NOT_INITIALIZED:
			return ("IIAPI_ST_NOT_INITIALIZED");
		case IIAPI_ST_INVALID_HANDLE:
			return ("IIAPI_ST_INVALID_HANDLE");
                case IIAPI_ST_OUT_OF_MEMORY:
                        return ("IIAPI_ST_OUT_OF_MEMORY");
                default:
                        return ("Unknow status");
        }
} 

void syc_getErrorInfo(II_PTR errorHandle)
{
        IIAPI_GETEINFOPARM      iiapi_geteinfoparm;
 
        if ( errorHandle == NULL )      return;
        iiapi_geteinfoparm.ge_errorHandle = errorHandle;
        IIapi_getErrorInfo(&iiapi_geteinfoparm);
        while (iiapi_geteinfoparm.ge_status == IIAPI_ST_SUCCESS)
        {
                fprintf(stderr, "\tType of message:\t");
                switch (iiapi_geteinfoparm.ge_type)
                {
                        case IIAPI_GE_ERROR:
                                fprintf(stderr, "IIAPI_GE_ERROR");
                                break;
                        case IIAPI_GE_WARNING:
                                fprintf(stderr, "IIAPI_GE_WARNING");
                                break;
                        case IIAPI_GE_MESSAGE:
                                fprintf(stderr, "IIAPI_GE_MESSAGE");
                                break;
                        default:
                                fprintf(stderr, "Unknown type");
                                break;
                }
                fprintf(stderr, "\n\tSQLstate:\t%s\n",
                        iiapi_geteinfoparm.ge_SQLSTATE);
                fprintf(stderr, "\tError code:\t%ld\n",
                        iiapi_geteinfoparm.ge_errorCode);
                fprintf(stderr, "\tMessage:\t%s\n",
                        iiapi_geteinfoparm.ge_message);
                if (iiapi_geteinfoparm.ge_serverInfoAvail == TRUE)
                {
                        int i;
 
                        fprintf(stderr, "\tsvr_id_error:\t%ld\n",
                            iiapi_geteinfoparm.ge_serverInfo->svr_id_error);
                        fprintf(stderr, "\tsvr_local_error:\t%ld\n",
                            iiapi_geteinfoparm.ge_serverInfo->svr_local_error);
                        fprintf(stderr, "\tsvr_id_server:\t%ld\n",
                            iiapi_geteinfoparm.ge_serverInfo->svr_id_server);
                        fprintf(stderr, "\tsvr_server_type:\t%ld\n",
                            iiapi_geteinfoparm.ge_serverInfo->svr_server_type);
                        fprintf(stderr, "\tsvr_severity:\t");
                        switch (iiapi_geteinfoparm.ge_serverInfo->svr_severity)
                        {
                                case IIAPI_SVR_DEFAULT:
                                        fprintf(stderr, "IIAPI_SVR_DEFAULT");
                                        break;
                                case IIAPI_SVR_MESSAGE:
                                        fprintf(stderr, "IIAPI_SVR_MESSAGE");
                                        break;
                                case IIAPI_SVR_WARNING:
                                        fprintf(stderr, "IIAPI_SVR_WARNING");
                                        break;
                                case IIAPI_SVR_FORMATTED:
                                        fprintf(stderr, "IIAPI_SVR_FROMATTED");
                                        break;
                                default:
                                        fprintf(stderr, "unknownn");
                                        break;
                        }
                        fprintf(stderr, "\n");
                        for (i=0; i<iiapi_geteinfoparm.
                                        ge_serverInfo->svr_parmCount; i++)
                        {
                                fprintf(stderr, "not implemented\n");
                        }
                }
                else
                        fprintf(stderr, "\tno more infomation available\n");
                IIapi_getErrorInfo(&iiapi_geteinfoparm);
        }
        return;
}
!!
? fill syc_2phase.c 
!!
/*
** Name:syc_2phase.c
**
** Description:
**
** History
** 	15-May-95(Manfu)
**	   creation
**
*/
#include <string.h>

/* Initialization using API input parameters */

#include "header.h"

IIAPI_INITPARM		iiapi_initparm;
IIAPI_TERMPARM		iiapi_termparm;
IIAPI_CONNPARM		iiapi_connparm;
IIAPI_DISCONNPARM	iiapi_disconnparm;
IIAPI_QUERYPARM		iiapi_queryparm;
IIAPI_CLOSEPARM		iiapi_closeparm;
IIAPI_GETQINFOPARM	iiapi_getqinfoparm;
IIAPI_REGXIDPARM	iiapi_regxidparm;
IIAPI_RELXIDPARM	iiapi_relxidparm;
IIAPI_PREPCMTPARM	iiapi_prepcmtparm;
IIAPI_COMMITPARM	iiapi_commitparm;
IIAPI_ROLLBACKPARM	iiapi_rollbackparm;
IIAPI_STATUS		prepcmtstatus, prepcmtstatus2;
Handleparm		handleparm, handleparm2;

void subroutine1()
{
	iiapi_regxidparm.rg_tranID.ti_type = IIAPI_TI_IIXID;
	iiapi_regxidparm.rg_tranID.ti_value.iiXID.ii_tranID.it_highTran
		= 0xABCDEF98; 
	iiapi_regxidparm.rg_tranID.ti_value.iiXID.ii_tranID.it_lowTran
		=  0x76543210;
	strcpy(iiapi_regxidparm.rg_tranID.ti_value.iiXID.ii_tranName,
		"myTransactionID");
	syc_registerXID(&iiapi_regxidparm);

	return;
}

void subroutine2()
{
	handleparm.hp_tranHandle = NULL; 

	iiapi_connparm.co_target = "apidb1";
	iiapi_connparm.co_username = "testenv";
	iiapi_connparm.co_password = NULL;
	iiapi_connparm.co_timeout = CONNTIMEOUT;
	syc_connect(&handleparm, &iiapi_connparm);

	return;
}

void subroutine3()
{
	iiapi_connparm.co_target = "apidb2";
	iiapi_connparm.co_username = "testenv";
	iiapi_connparm.co_password = NULL;
	iiapi_connparm.co_timeout = CONNTIMEOUT;
	syc_connect(&handleparm2, &iiapi_connparm);

	return;
}
	
void dropTable1()
{
	II_CHAR *sqlStmt = "drop table mytable1";
	II_CHAR *SqlStmt = "drop table mytable2";

	iiapi_queryparm.qy_queryType = IIAPI_QT_QUERY;
	iiapi_queryparm.qy_parameters = FALSE;
	iiapi_queryparm.qy_queryText = sqlStmt;
	printf("Now, database is doing %s\n",iiapi_queryparm.qy_queryText);
	syc_query(&handleparm, &iiapi_queryparm);
	syc_getQueryInfo(&handleparm, &iiapi_getqinfoparm);
	syc_close(&handleparm, &iiapi_closeparm);
	syc_commit(&handleparm, &iiapi_commitparm);

	iiapi_queryparm.qy_queryType = IIAPI_QT_QUERY;
	iiapi_queryparm.qy_parameters = FALSE;
	iiapi_queryparm.qy_queryText = SqlStmt;
	printf("Now, database is doing %s\n",iiapi_queryparm.qy_queryText);
	syc_query(&handleparm2, &iiapi_queryparm);
	syc_getQueryInfo(&handleparm2, &iiapi_getqinfoparm);
	syc_close(&handleparm2, &iiapi_closeparm);
	syc_commit(&handleparm2, &iiapi_commitparm);

	return;
}

void subroutine4()
{
	handleparm.hp_tranHandle = iiapi_regxidparm.rg_tranIdHandle;

	iiapi_queryparm.qy_queryType = IIAPI_QT_QUERY;
	iiapi_queryparm.qy_parameters = FALSE;
	iiapi_queryparm.qy_queryText ="create table mytable1(col1 integer) with page_size=8-
192";
	syc_query(&handleparm, &iiapi_queryparm);

	return;
}

void subroutine5()
{
	handleparm2.hp_tranHandle = iiapi_regxidparm.rg_tranIdHandle;

	iiapi_queryparm.qy_queryType = IIAPI_QT_QUERY;
	iiapi_queryparm.qy_parameters = FALSE;
	iiapi_queryparm.qy_queryText ="create table mytable2(col2 integer) with page_size=8-
192";
	syc_query(&handleparm2, &iiapi_queryparm);
}

void subroutine6()
{
	syc_getQueryInfo(&handleparm, &iiapi_getqinfoparm);

	return;
}

void subroutine7()
{
	syc_getQueryInfo(&handleparm2, &iiapi_getqinfoparm);

	return;
}

void subroutine8()
{
	syc_close(&handleparm, &iiapi_closeparm);

	return;
}

void subroutine9()
{
	syc_close(&handleparm2, &iiapi_closeparm);

	return;
}

void subroutine10()
{
	syc_prepareCommit(&handleparm, &iiapi_prepcmtparm);
	prepcmtstatus = iiapi_prepcmtparm.pr_genParm.gp_status;

	return;
}

void subroutine11()
{
	syc_prepareCommit(&handleparm2, &iiapi_prepcmtparm);
	prepcmtstatus2 = iiapi_prepcmtparm.pr_genParm.gp_status;

	return;
}

void subroutine12()
{
	syc_commit(&handleparm, &iiapi_commitparm);

	return;
}

void subroutine13()
{
	syc_commit(&handleparm2, &iiapi_commitparm);

	return;
}

void subroutine14()
{
	iiapi_rollbackparm.rb_savePointHandle = NULL;
	syc_rollback(&handleparm, &iiapi_rollbackparm);

	return;
}

void subroutine15()
{
	iiapi_rollbackparm.rb_savePointHandle = NULL;
	syc_rollback(&handleparm2, &iiapi_rollbackparm);

	return;
}

void subroutine16()
{
	iiapi_relxidparm.rl_tranIdHandle = iiapi_regxidparm.rg_tranIdHandle;
	syc_releaseXID(&iiapi_relxidparm);

	return;
}

void subroutine17()
{
	syc_disconnect(&handleparm, &iiapi_disconnparm);

	return;
}

void subroutine18()
{
	syc_disconnect(&handleparm2, &iiapi_disconnparm);

	return;
}

int main()
{
	int index;
	void (*func_array1[])() = {
		subroutine1,
		subroutine2,
		subroutine3,
		dropTable1,
		subroutine4,
		subroutine5,
		subroutine6,
		subroutine7,
		subroutine8,
		subroutine9,
		subroutine10,
		subroutine11,
		NULL
	};
	void (*func_array2[])() = {
		subroutine12,
		subroutine13,
		NULL
	};
	void (*func_array3[])() = {
		subroutine14,
		subroutine15,
		NULL
	};
	void (*func_array4[])() = {
		subroutine16,
		subroutine17,
		subroutine18,
		NULL
	};

	handleparm.hp_tranHandle = NULL;
	handleparm.hp_stmtHandle = NULL;

	iiapi_initparm.in_timeout = -1;
	iiapi_initparm.in_version = IIAPI_VERSION_2;
	iiapi_initparm.in_envHandle = NULL;

	syc_initialize(&iiapi_initparm);
	
	handleparm.hp_connHandle = iiapi_initparm.in_envHandle;
	handleparm2 = handleparm;

	index = 0;
	while (func_array1[index] != NULL)
	{
		func_array1[index++]();
	}

	index = 0;
	if (prepcmtstatus == IIAPI_ST_SUCCESS &&
	    prepcmtstatus2 == IIAPI_ST_SUCCESS)
	{
		while (func_array2[index] != NULL)
		{
			func_array2[index++]();
		}
	}
	else
	{
		while (func_array3[index] != NULL)
		{
			func_array3[index++]();
		}
	}

	index = 0;
	while (func_array4[index] != NULL)
	{
		func_array4[index++]();
	}
	
	syc_releaseEnv( iiapi_initparm.in_envHandle );
	syc_terminate(&iiapi_termparm);

       return(0);
}
!!
? sepcc syc_2phase synchronous myfile 
<<
>>
<< IF (NT_GENERIC)
syc_2phase.c
synchronous.c
myfile.c
>>
.if (VMS) 
? seplnk -a syc_2phase synchronous myfile 
<<
>>
.else 
? seplnk syc_2phase synchronous myfile 
<<
>>
.endif 
? run syc_2phase.exe 
<<
	Type of message:	IIAPI_GE_ERROR
	SQLstate:	42500
	Error code:	2753
	Message:	DROP: 'mytable1' does not exist or is not owned by you.
	svr_id_error:	67653632
	svr_local_error:	2753
	svr_id_server:	13599
	svr_server_type:	0
	svr_severity:	IIAPI_SVR_DEFAULT
not implemented
	Type of message:	IIAPI_GE_ERROR
	SQLstate:	42500
	Error code:	2753
	Message:	DROP: 'mytable2' does not exist or is not owned by you.
	svr_id_error:	67653632
	svr_local_error:	2753
	svr_id_server:	13599
	svr_server_type:	0
	svr_severity:	IIAPI_SVR_DEFAULT
not implemented
IIapi_initialize return status:	IIAPI_ST_SUCCESS
IIapi_registerXID return status:	IIAPI_ST_SUCCESS
IIapi_connect return status:	IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
	apiLevel:	1
IIapi_connect return status:	IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
	apiLevel:	1
Now, database is doing drop table mytable1
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_ERROR
	gq_flags:
			IIAPI_GQF_FAIL
			IIAPI_GQF_TRANSACTION_INACTIVE
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
Now, database is doing drop table mytable2
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_ERROR
	gq_flags:
			IIAPI_GQF_FAIL
			IIAPI_GQF_TRANSACTION_INACTIVE
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
iiapi_query return status:	IIAPI_ST_SUCCESS
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_SUCCESS
	No response data is available
IIapi_getQueryInfo return status:	IIAPI_ST_SUCCESS
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:	IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
IIapi_releaseXID return status:	IIAPI_ST_SUCCESS
IIapi_disconnect return status:	IIAPI_ST_SUCCESS
IIapi_disconnect return status:	IIAPI_ST_SUCCESS
Releasing API environment...
Successfully, released API environment
IIapi_terminate return status:	IIAPI_ST_SUCCESS
>>
<< IF (NT_GENERIC) 
IIapi_initialize return status:	IIAPI_ST_SUCCESS
IIapi_registerXID return status:	IIAPI_ST_SUCCESS
IIapi_connect return status:	IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
	apiLevel:	1
IIapi_connect return status:	IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
	apiLevel:	1
Now, database is doing drop table mytable1
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_ERROR
	gq_flags:
			IIAPI_GQF_FAIL
			IIAPI_GQF_TRANSACTION_INACTIVE
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
Now, database is doing drop table mytable2
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_ERROR
	gq_flags:
			IIAPI_GQF_FAIL
			IIAPI_GQF_TRANSACTION_INACTIVE
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
iiapi_query return status:	IIAPI_ST_SUCCESS
iiapi_query return status:	IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:	IIAPI_ST_SUCCESS
	No response data is available
IIapi_getQueryInfo return status:	IIAPI_ST_SUCCESS
	No response data is available
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_close return status:	IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:	IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
IIapi_commit return status:	IIAPI_ST_SUCCESS
IIapi_releaseXID return status:	IIAPI_ST_SUCCESS
IIapi_disconnect return status:	IIAPI_ST_SUCCESS
IIapi_disconnect return status:	IIAPI_ST_SUCCESS
Releasing API environment...
Successfully, released API environment
IIapi_terminate return status:	IIAPI_ST_SUCCESS
	Type of message:	IIAPI_GE_ERROR
	SQLstate:	42500
	Error code:	2753
	Message:	DROP: 'mytable1' does not exist or is not owned by you.
	svr_id_error:	67653632
	svr_local_error:	2753
	svr_id_server:	258
	svr_server_type:	0
	svr_severity:	IIAPI_SVR_DEFAULT
not implemented
	Type of message:	IIAPI_GE_ERROR
	SQLstate:	42500
	Error code:	2753
	Message:	DROP: 'mytable2' does not exist or is not owned by you.
	svr_id_error:	67653632
	svr_local_error:	2753
	svr_id_server:	258
	svr_server_type:	0
	svr_severity:	IIAPI_SVR_DEFAULT
not implemented
>>
<< if (VMS)
IIapi_initialize return status: IIAPI_ST_SUCCESS
IIapi_registerXID return status:        IIAPI_ST_SUCCESS
IIapi_connect return status:    IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
        apiLevel:       1
IIapi_connect return status:    IIAPI_ST_SUCCESS
	sizeAdvise: (looks OK, suppressed)
        apiLevel:       1
Now, database is doing drop table mytable1
iiapi_query return status:      IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:       IIAPI_ST_ERROR
        Type of message:        IIAPI_GE_ERROR
        SQLstate:       42500
        Error code:     2753
        Message:        DROP: 'mytable1' does not exist or is not owned by you.
        svr_id_error:   67653632
        svr_local_error:        2753
        svr_id_server:  30183
        svr_server_type:        0
        svr_severity:   IIAPI_SVR_DEFAULT
not implemented
        gq_flags:
                        IIAPI_GQF_FAIL
                        IIAPI_GQF_TRANSACTION_INACTIVE
        No response data is available
IIapi_close return status:      IIAPI_ST_SUCCESS
IIapi_commit return status:     IIAPI_ST_SUCCESS
Now, database is doing drop table mytable2
iiapi_query return status:      IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:       IIAPI_ST_ERROR
        Type of message:        IIAPI_GE_ERROR
        SQLstate:       42500
        Error code:     2753
        Message:        DROP: 'mytable2' does not exist or is not owned by you.
        svr_id_error:   67653632
        svr_local_error:        2753
        svr_id_server:  30183
        svr_server_type:        0
        svr_severity:   IIAPI_SVR_DEFAULT
not implemented
        gq_flags:
                        IIAPI_GQF_FAIL
                        IIAPI_GQF_TRANSACTION_INACTIVE
        No response data is available
IIapi_close return status:      IIAPI_ST_SUCCESS
IIapi_commit return status:     IIAPI_ST_SUCCESS
iiapi_query return status:      IIAPI_ST_SUCCESS
iiapi_query return status:      IIAPI_ST_SUCCESS
IIapi_getQueryInfo return status:       IIAPI_ST_SUCCESS
        No response data is available
IIapi_getQueryInfo return status:       IIAPI_ST_SUCCESS
        No response data is available
IIapi_close return status:      IIAPI_ST_SUCCESS
IIapi_close return status:      IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:      IIAPI_ST_SUCCESS
IIapi_prepareCommit return status:      IIAPI_ST_SUCCESS
IIapi_commit return status:     IIAPI_ST_SUCCESS
IIapi_commit return status:     IIAPI_ST_SUCCESS
IIapi_releaseXID return status: IIAPI_ST_SUCCESS
IIapi_disconnect return status: IIAPI_ST_SUCCESS
IIapi_disconnect return status: IIAPI_ST_SUCCESS
Releasing API environment...
Successfully, released API environment
IIapi_terminate return status:  IIAPI_ST_SUCCESS
>>
? sql -s apidb1 
<<

>>
* drop table mytable1;\g 
<<
>>
* \q 
<<
~
>>
? sql -s apidb2 
<<

>>
* drop table mytable2;\g 
<<
>>
* \q 
<<
~
>>
? delete iiapi_edit.com 
<<
~
>>
? delete syc_2phase.exe 
<<
~
>>
? delete syc_2phase.obj 
<<
~
>>
? delete synchronous.obj 
<<
~
>>
? delete myfile.obj 
<<
~
>>
? delete syc_2phase.o 
<<
~
>>
? delete synchronous.o 
<<
~
>>
? delete myfile.o 
<<
~
>>
? delete iiapi.h 
<<
~
>>
? delete iiapi.tmp 
<<
~
>>
? delete iiapidep.h 
<<
~
>>
.endif


Ending at: Thu Dec 30 03:00:38 1999
