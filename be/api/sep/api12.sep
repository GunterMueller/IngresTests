/*
	Test Name: api12.aep
	Time: Wed Dec 15 14:53:01 1999
	User Name: testenv
	Terminal type: septerm
 
	Test ID : (TBD)
	Module  : 
	Filename:
	Purpose	:
	Input Files  :
	Output Files :
	Database     :
	Tables       :
	Synopsis     :

 History: 15-Dec-1999	(ngutr03)	Created
	  01-Sep-2000   (vande02)	Added 'run' to execution syntax for
					'nameserver.exe' so it will run on
					HP-UX and other unix platforms.
	  17-sep-2001   (devjo01)	Changed failure tests to make sure
					program will not infinitely loop
					if an error code other than
					IIAPI_ST_NO_DATA is returned.
	11-jun-2003 (abbjo03)
		Corrections to eliminate warnings on VMS.
*/
? cp @file(ii_system,ingres,files,iiapidep.h) iiapidep.h 
<<
~
>>
? cp @file(ii_system,ingres,files,iiapi.h) iiapi.tmp 
<<
~
>>
.if (NT_GENERIC) 
? fill makeiiapi.bat 
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h 
!!
? run makeiiapi.bat 
<<
~
>>
.endif
.if (UNIX) 
? fill makeiiapi.sh
!!
sed  "s/<iiapidep.h>/\"iiapidep.h\"/g" iiapi.tmp > iiapi.h
!!
? sh  makeiiapi.sh
<<
>>
.endif 
.if (VMS)
? fill iiapi_edit.com
!!
$ pipe sed "s/<iiapidep.h>/""iiapidep.h""/g" iiapi.tmp > iiapi.h
!!
? qasetuser testenv @iiapi_edit.com
<<
>>
.endif
? fill nameserver.c 
!!
/***********************************************************************************-
*****
** Implementation File: nameserver.c												   **
** Author:              ngutr03                                                     -
   **
** Last Revision:       November 22, 1999               							   **
** Description:         OpenAPI version 2 supports applications to perform          -
   **
**                      operations on the Name Server database.                     -
   **
** Purpose:             Testing all of the operations on the Name Server Database   -
   **
**                                                                                  -
   **
**                        OPERATIONS ON THE NAME SERVER DATABASE                    -
   **
**                        ======================================                    -
   **
**             *************************************************************        -
   **
**             | Operation        | Description                            |        -
   **
**             *************************************************************        -
   **
**             | Create           | Creates a new connection data entry or |        -
   **
**             |                  | remote user authorization or attribute |        -
   **
**             |                  | data entry.                            |        -
   **
**             *************************************************************        -
   **
**             | Destroy          | Destroys a connection data entry or    |        -
   **
**             |                  | remote user authorization or attribute |        -
   **
**             |                  | data entry.                            |        -
   **
**             *************************************************************        -
   **
**             | Show             | Displays information to the application|        -
   **
**             *************************************************************        -
   **
**                                                                                  -
   **
************************************************************************************-
*****/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "iiapi.h"
#include "iiapidep.h"

/* function prototypes */
II_PTR API_Initialize(II_LONG);										   /* Initialize environment */
void API_DisplayStatus(char*, IIAPI_STATUS);						   /* Display status of the functi-
on */
void API_ReleaseEnv(II_PTR);										   /* Free the environment handle */
void API_Disconnect(II_PTR, char*);	     							   /* Disconnect from a DBMS or Name-
 Server */
II_PTR API_Connect(IIAPI_CONNPARM*);								   /* Connect to DBMS or Name server */
void API_DisplayErrorInfo(II_PTR);									   /* Display Error Message Information *-
/
void API_Wait(IIAPI_GENPARM *);									       /* Wait if the task is not finished *-
/
void API_Terminate();										           /* Clean up all */
void API_ExecQuery(char*, II_PTR, II_PTR);                             /* Execute SQ-
L query */
void API_Show(char* , II_PTR, II_PTR);					               /* Display Name Server Dat-
a */
void API_GetQueryInfo(IIAPI_QUERYPARM*);							   /* Get Information about a query *-
/
IIAPI_QUERYPARM API_Query(char*, IIAPI_QUERYTYPE, II_PTR, II_PTR);     /* Allocate Q-
uery Statement Handle */
void API_ReleaseStmtHandle(II_PTR);									   /* Free Statement Handle */
int API_GetDescriptor(II_PTR, IIAPI_GETDESCRPARM*); 		           /* Communicate the -
format of the data to be returned with IIapi_getcolumns() */
II_PTR API_Autocommit(II_PTR, II_PTR);						           /* Set autocommit ON/OFF */
void API_GetColumns(II_PTR, IIAPI_DESCRIPTOR*, IIAPI_GETCOLPARM*,int); /* Get and Di-
splay Data from a select statement */
void API_printLine();

/***********************************************************************************-
**
** Function Name: API_Initialize				    								**
** Description:   Allocates an environment handle and returns it to the application -
**
** Input:         timeout                											**
** Return value:  Environment Handle    											**
************************************************************************************-
**/

II_PTR API_Initialize(II_LONG timeout)
{
	IIAPI_INITPARM iiapi_initparm;

	iiapi_initparm.in_timeout = timeout;
	iiapi_initparm.in_version = IIAPI_VERSION_2;
	iiapi_initparm.in_envHandle = NULL;

	printf("Initializing API environment...\n");
	IIapi_initialize(&iiapi_initparm);

	printf("%s\n", (iiapi_initparm.in_status == IIAPI_ST_SUCCESS) ? "Successfully, init-
ialized API environment" : "Failed to initialize API environment");
	API_DisplayStatus("IIapi_initialize", iiapi_initparm.in_status);
	API_printLine();

	return(iiapi_initparm.in_envHandle);
}

/***********************************************************************************-
**
** Function Name: API_ReleaseEnv													**
** Description:   Frees an environment handle and any resources associated with the -
**
**                environment handle.												**
** Input:         envHandle															**
** Return value:  None																**	
************************************************************************************-
**/

void API_ReleaseEnv(II_PTR envHandle)
{
	IIAPI_RELENVPARM relEnvParm;

	relEnvParm.re_envHandle = envHandle;
	printf("Releasing API environment...\n");
	IIapi_releaseEnv(&relEnvParm);
	printf("%s\n", (relEnvParm.re_status == IIAPI_ST_SUCCESS) ? "Successfully, released-
 API environment" : "Failed to release API environment");

	API_DisplayStatus("IIapi_releaseEnv", relEnvParm.re_status);
	API_printLine();
}


/***********************************************************************************-
**
** Function Name: API_Connect														**
** Description:   Connects to the DBMS Server or Name Server based on               -
**
**                connection type		                                            **
** Input:         connParm															**
** Return value:  Connection Handle													**
************************************************************************************-
**/

II_PTR API_Connect(IIAPI_CONNPARM* connParm)
{
	printf("Establishing a connection to '%s' \n", (connParm->co_target != NULL) ? conn-
Parm->co_target : "LOCAL machine");
	IIapi_connect(connParm);
	
	/* wait until the task is completed... */
	API_Wait(&connParm->co_genParm);

	API_DisplayStatus("IIapi_connect", connParm->co_genParm.gp_status);
	if( connParm->co_genParm.gp_status == IIAPI_ST_SUCCESS )
	{
		printf("Successfully, connected to '%s'\n", (connParm->co_target != NULL) ? connPa-
rm->co_target : "LOCAL machine");
	}
	else
	{
		printf("*** Failed to connect to '%s'***\n\n", connParm->co_target);
		/* Display error messages if there are...*/
		if( connParm->co_genParm.gp_errorHandle != NULL )
		{
			API_DisplayErrorInfo(connParm->co_genParm.gp_errorHandle);	
		}
	}
	API_printLine();

	return(connParm->co_connHandle);
}

/***********************************************************************************-
**
** Function Name: API_Disconnect													**
** Description:   Closes a DBMS Server connection and frees the connection handle	**
** Input:         Connection Handle, target name									**
** Return value:  None																**
************************************************************************************-
**/

void API_Disconnect(II_PTR connHandle, char* co_target)
{
	IIAPI_DISCONNPARM disconnParm;

	disconnParm.dc_genParm.gp_callback = NULL;
	disconnParm.dc_connHandle = connHandle;
	
	printf("Disconnecting from '%s'... \n", (co_target != NULL) ? co_target : "LOCAL ma-
chine");
	IIapi_disconnect(&disconnParm);
	/* wait until the task is completed... */
	API_Wait(&disconnParm.dc_genParm);
	printf("%s'%s'\n", (disconnParm.dc_genParm.gp_status == IIAPI_ST_SUCCESS) ? "Succes-
sfully, disconnected from " : "Failed to disconnect from ", (co_target != NULL) ? co-
_target : "LOCAL machine");
	API_DisplayStatus("IIapi_disconnect", disconnParm.dc_genParm.gp_status);
	/* Display error messages if there are...*/
	if( disconnParm.dc_genParm.gp_errorHandle != NULL )
	{
		API_DisplayErrorInfo(disconnParm.dc_genParm.gp_errorHandle);	
	}
	API_printLine();
}

/***********************************************************************************-
**
** Function Name: API_DisplayErrorInfo  											**
** Description:   Displays Error Messages                                   		**
** Input:         errorHandle  														**
** Return value:  None      														**
************************************************************************************-
**/

void API_DisplayErrorInfo(II_PTR errorHandle)
{
	IIAPI_GETEINFOPARM getEInfoParm;

	getEInfoParm.ge_errorHandle = errorHandle;

	while( TRUE )
	{
		IIapi_getErrorInfo(&getEInfoParm);
		if( getEInfoParm.ge_status == IIAPI_ST_NO_DATA )
			break;
		fprintf(stderr, "\tType of Message:");
		switch (getEInfoParm.ge_type)
		{
		case IIAPI_GE_ERROR:
			fprintf(stderr, "IIAPI_GE_ERROR");
			break;
		case IIAPI_GE_WARNING:
			fprintf(stderr, "IIAPI_GE_WARNING");
			break;
		case IIAPI_GE_MESSAGE:
			fprintf(stderr, "IIAPI_GE_MESSAGE");
			break;
		default:
			fprintf(stderr, "Unknown Message Type");
			break;
		}
		fprintf(stderr, "\n\tSQLState:\t%s\n", getEInfoParm.ge_SQLSTATE);
		fprintf(stderr, "\tError Code:\t%ld\n", getEInfoParm.ge_errorCode);
		fprintf(stderr, "\tMessage:\t%s\n\n", getEInfoParm.ge_message);

		if( getEInfoParm.ge_serverInfoAvail )
		{
			fprintf(stderr, "\tSVR_ID_Error:\t%ld\n", getEInfoParm.ge_serverInfo->svr_id_erro-
r);
			fprintf(stderr, "\tSVR_Local_Error:%ld\n", getEInfoParm.ge_serverInfo->svr_local_-
error);
			fprintf(stderr, "\tSVR_ID_Server:\t%ld\n", getEInfoParm.ge_serverInfo->svr_id_ser-
ver);
			fprintf(stderr, "\tSVR_Server_Type:%ld\n", getEInfoParm.ge_serverInfo->svr_server-
_type);
			fprintf(stderr, "\tSVR_Severity:\t");
			switch(getEInfoParm.ge_serverInfo->svr_severity)
			{
			case IIAPI_SVR_DEFAULT:
				fprintf(stderr, "IIAPI_SVR_DEFAULT");
				break;
			case IIAPI_SVR_MESSAGE:
				fprintf(stderr, "IIAPI_SVR_MESSAGE");
				break;
			case IIAPI_SVR_WARNING:
				fprintf(stderr, "IIAPI_SVR_WARNING");
				break;
			case IIAPI_SVR_FORMATTED:
				fprintf(stderr, "IIAPI_SVR_FORMATTED");
				break;
			default:
				fprintf(stderr, "Unknown");
				break;
			}
			fprintf(stderr, "\n");
		}
	}
	return;
}

/***********************************************************************************-
**
** Function Name: API_DisplayStatus													**
** Description:   Displays status of the function upon its return					**
** Input:         statusID															**
** Return value:  None																**				
************************************************************************************-
**/

void API_DisplayStatus(char* strMsg, IIAPI_STATUS statusID )
{
	printf("%s returned status = ", strMsg);
	switch(statusID)
	{
	case IIAPI_ST_SUCCESS:
		printf("IIAPI_ST_SUCCESS\n");
		break;
	case IIAPI_ST_WARNING:
		printf("IIAPI_ST_WARNING\n");
		break;
	case IIAPI_ST_OUT_OF_MEMORY:
		printf("IIAPI_ST_OUT_OF_MEMORY\n");
		break;
	case IIAPI_ST_FAILURE:
		printf("IIAPI_ST_FAILURE\n");
		break;
	case IIAPI_ST_NOT_INITIALIZED:
		printf("IIAPI_ST_NOT_INITIALIZED\n");
		break;
	case IIAPI_ST_INVALID_HANDLE:
		printf("IIAPI_ST_INVALID_HANDLE\n");
		break;
	case IIAPI_ST_MESSAGE:
		printf("IIAPI_ST_MESSAGE\n");
		break;
	case IIAPI_ST_ERROR:
		printf("IIAPI_ST_ERROR\n");
		break;
	case IIAPI_ST_NO_DATA:
		printf("IIAPI_ST_NO_DATA\n");
		break;
	default:
		printf("Unknown Status");
		break;
	}
}

/***********************************************************************************-
**
** Function Name: API_Wait		    					            		    	**
** Description:   Waits if the task is finished                                     -
**
** Input:         genParm								     						**
** Return value:  None				                  								**
************************************************************************************-
**/
void API_Wait(IIAPI_GENPARM* genParm)
{
	IIAPI_WAITPARM waitP;
	waitP.wt_timeout = -1;

    while (!genParm->gp_completed)
	{
        IIapi_wait(&waitP);
	}
	if( genParm->gp_status != IIAPI_ST_SUCCESS )
	{
		printf("Error in IIapi_wait\n");
		API_DisplayStatus("IIapi_wait", genParm->gp_status);
		if( genParm->gp_errorHandle != NULL )
		{
			/* Display error messages if there are...*/
			API_DisplayErrorInfo(genParm->gp_errorHandle);	
		}
	}
}

/***********************************************************************************-
**
** Function Name: API_Terminate		    					            		    **
** Description:   Clean up all                                                      -
**
** Input:         None									     						**
** Return value:  None				                  								**
************************************************************************************-
**/
void API_Terminate()
{
	IIAPI_TERMPARM termParm;
	/* Clean up */
	printf("Terminating API...\n");
	IIapi_terminate(&termParm);
	printf("%s\n", (termParm.tm_status == IIAPI_ST_SUCCESS) ? "Successfully, terminated-
 API" : "Failed to terminate API");
	API_DisplayStatus("IIapi_terminate", termParm.tm_status);

	printf("\t\t\t*** THE END ***\n");
}

/***********************************************************************************-
**
** Function Name: API_ExecQuery      					            		    	**
** Description:   Execute SQL query                                                 -
**
** Input:         stmtText, connHandle, tranHandle             						**
** Return value:  none                               								**
************************************************************************************-
**/

void API_ExecQuery(char* stmtText, II_PTR connHandle, II_PTR tranHandle)
{
	IIAPI_QUERYPARM queryParm;
	
	queryParm = API_Query(stmtText, IIAPI_QT_QUERY, connHandle, tranHandle);
	API_GetQueryInfo(&queryParm);
	API_ReleaseStmtHandle(queryParm.qy_stmtHandle);
	API_printLine();
}

/***********************************************************************************-
**
** Function Name: API_Show        					            			    	**
** Description:   Displays name server information							        **
** Input:         queryText, connHandle, tranHandle    								**
** Return value:  None                              								**
************************************************************************************-
**/

void API_Show(char* queryText, II_PTR connHandle, II_PTR tranHandle)
{
	IIAPI_GETDESCRPARM getDescrP;
    IIAPI_GETCOLPARM   getColP;
	int                nColumns = 0; /* Number of columns */
	IIAPI_QUERYPARM    queryParm;

	queryParm = API_Query(queryText, IIAPI_QT_QUERY, connHandle, tranHandle);
	nColumns  = API_GetDescriptor(queryParm.qy_stmtHandle, &getDescrP);
	if( nColumns > 0 )
		API_GetColumns(queryParm.qy_stmtHandle, getDescrP.gd_descriptor, &getColP, nColumn-
s);
	API_GetQueryInfo(&queryParm);

	API_ReleaseStmtHandle(queryParm.qy_stmtHandle);
	API_printLine();
}

/***********************************************************************************-
**
** Function Name: API_GetQueryInfo					            			    	**
** Description:   Returns information about a query                         		**
** Input:         queryP                            								**
** Return value:  Data associated with an SQL statement								**
************************************************************************************-
**/
void API_GetQueryInfo(IIAPI_QUERYPARM* queryP)
{
	IIAPI_GETQINFOPARM getQInfoP;
	getQInfoP.gq_genParm.gp_callback = NULL;
	getQInfoP.gq_genParm.gp_closure = NULL;
	getQInfoP.gq_stmtHandle = queryP->qy_stmtHandle;

	IIapi_getQueryInfo(&getQInfoP);
	
	 /* wait until the task is completed... */
	API_Wait(&getQInfoP.gq_genParm);
	
	if( getQInfoP.gq_flags & IIAPI_GQF_FAIL)
	{
		printf("Execution of query failed...\n");
		API_DisplayStatus("IIapi_getQueryInfo", getQInfoP.gq_genParm.gp_status);
		if( getQInfoP.gq_genParm.gp_errorHandle != NULL )
		{
			/* Display error messages if there are...*/
			API_DisplayErrorInfo(getQInfoP.gq_genParm.gp_errorHandle);	
		}
	}
	else
	{
		printf("->Statement processed\n");
	}
}

/***********************************************************************************-
**
** Function Name: API_ReleaseStmtHandle					            			    **
** Description:   Ends an SQL statement or database event retrieval and frees the	**
**                statement or event handle                                         -
**
** Input:         Statement handle                  								**
** Return value:  None                              								**
************************************************************************************-
**/
void API_ReleaseStmtHandle(II_PTR stmtHandle)
{
	IIAPI_CLOSEPARM iiapi_closeparm;
	
	iiapi_closeparm.cl_genParm.gp_callback = NULL;
    iiapi_closeparm.cl_stmtHandle = stmtHandle;

	IIapi_close(&iiapi_closeparm);

	/* wait until the task is completed... */
	API_Wait(&iiapi_closeparm.cl_genParm);

	if( iiapi_closeparm.cl_genParm.gp_errorHandle != NULL )
	{
		printf("Error in IIapi_close\n");
		API_DisplayStatus("IIapi_close", iiapi_closeparm.cl_genParm.gp_status);
		/* Display error messages if there are...*/
		API_DisplayErrorInfo(iiapi_closeparm.cl_genParm.gp_errorHandle);	
	}
}



/***********************************************************************************-
**
** Function Name: API_Autocommit    					            		    	**
** Description:   Enables or Disables an autocommit transaction                     -
**
** Input:         Connection Handle, Transaction Handle     						**
** Return value:  Transaction Handle                  								**
************************************************************************************-
**/
II_PTR API_Autocommit(II_PTR connHandle, II_PTR tranHandle)
{
	IIAPI_AUTOPARM autoParm;

	autoParm.ac_genParm.gp_callback = NULL;
	autoParm.ac_connHandle = connHandle;
	autoParm.ac_tranHandle = tranHandle;

	printf("set autocommit %s\n", (connHandle != NULL) ? "ON" : "OFF");
	IIapi_autocommit(&autoParm);

	/* wait until the task is completed... */
	API_Wait(&autoParm.ac_genParm);

	if( autoParm.ac_genParm.gp_status != IIAPI_ST_SUCCESS )
	{
		printf("Error in IIapi_autocommit\n");
		API_DisplayStatus("IIapi_autocommit", autoParm.ac_genParm.gp_status);
		if( autoParm.ac_genParm.gp_errorHandle != NULL )
		{
			/* Display error messages if there are...*/
			API_DisplayErrorInfo(autoParm.ac_genParm.gp_errorHandle);	
		}
	}

	API_printLine();

	return (autoParm.ac_tranHandle);
}

/***********************************************************************************-
**
** Function Name: API_GetColumns     					            			    **
** Description:   Returns the result of the SQL statement or database event         -
**
**                retrieval                                                         -
**
** Input:         Statement handle, getcolparm, descriptor         					**
** Return value:  None                              								**
************************************************************************************-
**/
void API_GetColumns(II_PTR stmtHandle, IIAPI_DESCRIPTOR* iiapi_descriptor,IIAPI_GETC-
OLPARM* iiapi_getcolparm, int Columns)
{
	IIAPI_DATAVALUE* iiapi_datavalue;
	int i, j, k;
	char *buffer;
    int  actsize;
	char szbuffer[17];
	IIAPI_CONVERTPARM iiapi_convertparm;

	iiapi_getcolparm->gc_genParm.gp_callback = NULL;
	iiapi_getcolparm->gc_stmtHandle = stmtHandle;
	iiapi_getcolparm->gc_rowCount = 1;
	iiapi_getcolparm->gc_columnCount = Columns;

	/* allocate memory */
	iiapi_getcolparm->gc_columnData = iiapi_datavalue =
                (IIAPI_DATAVALUE *) malloc(iiapi_getcolparm->gc_rowCount *
                iiapi_getcolparm->gc_columnCount * sizeof(IIAPI_DATAVALUE));

	for (i=0, k=0; i<iiapi_getcolparm->gc_rowCount; i++)
	{
		for (j=0; j<iiapi_getcolparm->gc_columnCount; j++, k++)
		{
			iiapi_datavalue[k].dv_value = (II_PTR) malloc(iiapi_descriptor[j].ds_length);
		}
	}
	printf("\n");
	while( TRUE )
	{
		IIapi_getColumns( iiapi_getcolparm );
		/* wait the IIapi_getColumns to finish */
		API_Wait( &iiapi_getcolparm->gc_genParm );
		
		/* if there is error message, print it out */
		if( iiapi_getcolparm->gc_genParm.gp_errorHandle != NULL )
		{
			API_DisplayStatus("IIapi_getColumns", iiapi_getcolparm->gc_genParm.gp_status);
			/* Display error messages if there are...*/
			API_DisplayErrorInfo( iiapi_getcolparm->gc_genParm.gp_errorHandle );	
		}

        if (iiapi_getcolparm->gc_genParm.gp_status >= IIAPI_ST_NO_DATA )
			break;
		/* print information of columns in a table */
        for (i=0, k=0; i<iiapi_getcolparm->gc_rowsReturned; i++)
        {
			for (j=0; j<iiapi_getcolparm->gc_columnCount; j++, k++)
			{
				printf("\t%s: ", iiapi_descriptor[j].ds_columnName);
				switch (iiapi_datavalue[k].dv_null)
				{
				case TRUE:
					printf("NULL");
					break;
				case FALSE:
					switch (iiapi_descriptor[j].ds_dataType)
					{
					case IIAPI_BYTE_TYPE:
					case IIAPI_CHA_TYPE:
					case IIAPI_CHR_TYPE:
					case IIAPI_VBYTE_TYPE:
					case IIAPI_LBYTE_TYPE:
					case IIAPI_LVCH_TYPE:
					case IIAPI_TXT_TYPE:
						actsize = iiapi_descriptor[j].ds_length;
                        buffer = (char*)malloc(actsize + 1);
                        strncpy(buffer, (char*)iiapi_datavalue[k].dv_value, actsize)-
;
                        buffer[actsize] = '\0';
                        printf("%s", buffer);
                        free(buffer);
                        break;
                    case IIAPI_VCH_TYPE:
                        actsize = *(unsigned short*)iiapi_datavalue[k].dv_value;
                        buffer = (char*)malloc(actsize + 1);
                        strncpy(buffer, (char*)iiapi_datavalue[k].dv_value + 2, acts-
ize);
                        buffer[actsize] = '\0';
                        printf("%s", buffer);
                        free(buffer);
                        break;
                    case IIAPI_HNDL_TYPE:
                        printf("%p", iiapi_datavalue[k].dv_value);
                        break;
                    case IIAPI_FLT_TYPE:
                        switch (iiapi_descriptor[j].ds_length)
                        {
                            case 4:
                                printf("%f",*(float*)iiapi_datavalue[k].dv_value);
                                break;
                            case 8:
                                printf("%lf",*(double*)iiapi_datavalue[k].dv_value);
                                break;
                            default:
                                printf("Unknown size");
                                break;
                        }
                        break;
                    case IIAPI_INT_TYPE:
                        switch (iiapi_descriptor[j].ds_length)
                        {
                            case 1:
                                printf("%d", *(char*)iiapi_datavalue[k].dv_value);
                                break;
                            case 2:
                                printf("%d", *(short*)iiapi_datavalue[k].dv_value);
                                break;
                            case 4:
                                printf("%ld", *(long*)iiapi_datavalue[k].dv_value);
                                break;
                            default:
                                printf("Unknown size");
                                break;
                        }
                        break;
                    case IIAPI_LOGKEY_TYPE:
                        strncpy(szbuffer, iiapi_datavalue[k].dv_value, 16);
                        szbuffer[16] = '\0';
                        printf("%s", szbuffer);
                        break;
                    case IIAPI_TABKEY_TYPE:
						strncpy(szbuffer, iiapi_datavalue[k].dv_value, 8);
                        szbuffer[16] = '\0';
                        printf("%s", szbuffer);
                        break;
                    case IIAPI_DEC_TYPE:
                        printf("Incompatible data type with C");
                        break;
                    case IIAPI_DTE_TYPE:  /* convert date type to char */
						iiapi_convertparm.cv_srcDesc = iiapi_descriptor[j];
                        iiapi_convertparm.cv_srcDesc.ds_nullable = TRUE;
 
                        iiapi_convertparm.cv_srcValue = iiapi_datavalue[k];
 
                        iiapi_convertparm.cv_dstDesc = iiapi_descriptor[j];
                        iiapi_convertparm.cv_dstDesc.ds_dataType = IIAPI_CHA_TYPE;
                        iiapi_convertparm.cv_dstDesc.ds_nullable = TRUE;
                        iiapi_convertparm.cv_dstDesc.ds_length = 26;
 
                        iiapi_convertparm.cv_dstValue.dv_null = FALSE;
                        iiapi_convertparm.cv_dstValue.dv_length = iiapi_convertparm.-
cv_dstDesc.ds_length;
                        iiapi_convertparm.cv_dstValue.dv_value = (II_PTR)malloc(iiap-
i_convertparm.cv_dstValue.dv_length + 1);
 
                        *((char *)iiapi_convertparm.cv_dstValue.dv_value + iiapi_con-
vertparm.cv_dstDesc.ds_length) = '\0';
 
                        IIapi_convertData(&iiapi_convertparm);
 
                        switch (iiapi_convertparm.cv_status)
                        {
                            case IIAPI_ST_SUCCESS:
                                printf("%s", (char *)iiapi_convertparm.cv_dstValue.d-
v_value);
                                break;
                            case IIAPI_ST_FAILURE:
                                printf("\nIIapi_convertData return:\t");
                                printf("IIAPI_ST_FAILURE");
                                break;
                            default:
                                printf("\nIIapi_convertData return:\t");
                                printf("Unknown status");
                                break;
                        }
                        free(iiapi_convertparm.cv_dstValue.dv_value);
 
                        break;
                    case IIAPI_MNY_TYPE:    /* convert money to char */             -
    
                        iiapi_convertparm.cv_srcDesc = iiapi_descriptor[j];
                        iiapi_convertparm.cv_srcDesc.ds_nullable = TRUE;
 
                        iiapi_convertparm.cv_srcValue = iiapi_datavalue[k];
 
                        iiapi_convertparm.cv_dstDesc = iiapi_descriptor[j];
                        iiapi_convertparm.cv_dstDesc.ds_dataType = IIAPI_CHA_TYPE;
                        iiapi_convertparm.cv_dstDesc.ds_nullable = TRUE;
                        iiapi_convertparm.cv_dstDesc.ds_length = 20;
 
                        iiapi_convertparm.cv_dstValue.dv_null = FALSE;
                        iiapi_convertparm.cv_dstValue.dv_length =
                                iiapi_convertparm.cv_dstDesc.ds_length;
                        iiapi_convertparm.cv_dstValue.dv_value = (II_PTR)malloc(iiap-
i_convertparm.cv_dstValue.dv_length + 1);
 
                        *((char *)iiapi_convertparm.cv_dstValue.dv_value + iiapi_con-
vertparm.cv_dstDesc.ds_length) = '\0';
 
                        IIapi_convertData(&iiapi_convertparm);
 
                        switch (iiapi_convertparm.cv_status)
                        {
                            case IIAPI_ST_SUCCESS:
                                printf("%s", (char *)iiapi_convertparm.cv_dstValue.d-
v_value);
                                break;
                            case IIAPI_ST_FAILURE:
                                printf("\nIIapi_convertData return:\t");
                                printf("IIAPI_ST_FAILURE");
                                break;
                            default:
                                printf("\nIIapi_convertData return:\t");
                                printf("Unknown status");
                                break;
                        }
                        free(iiapi_convertparm.cv_dstValue.dv_value);
 
                        break;
                    default:
                        printf("Unknown data type");
                        break;
					}
                break;
              default:
                printf("Unknown: %d", iiapi_datavalue[k].dv_null);
                break;
			  }
		      printf("\n");
		   }
		   printf("=========================================\n");
		}
	}
	for (i=0, k=0; i<iiapi_getcolparm->gc_rowCount; i++)
	{
		for (j=0; j<iiapi_getcolparm->gc_columnCount; j++, k++)
		{
			free(iiapi_datavalue[k].dv_value);
		}
	}
	free(iiapi_datavalue);
	
	return;
}

/***********************************************************************************-
**
** Function Name: API_Query         					            				**
** Description:   Begins an SQL statement and allocates a statement handle     		**
** Input:         connHandle, tranHandle, SQLStmt, queryType    					**
** Return value:  queryParm         												**
************************************************************************************-
**/
IIAPI_QUERYPARM API_Query(char* SQLStmt, IIAPI_QUERYTYPE queryType, II_PTR connHandl-
e, II_PTR tranHandle)
{
	IIAPI_QUERYPARM queryParm;

	queryParm.qy_genParm.gp_callback = NULL;
	queryParm.qy_genParm.gp_closure = NULL;
  	queryParm.qy_connHandle = connHandle;
	queryParm.qy_stmtHandle = NULL;
	queryParm.qy_tranHandle = tranHandle;
	queryParm.qy_queryType = queryType;
	queryParm.qy_parameters = FALSE;
	queryParm.qy_queryText = SQLStmt;

	printf("SQL> %s\n", SQLStmt);
	printf("Executing . . .\n");
	IIapi_query(&queryParm);
    /* wait until the task is completed... */
	API_Wait(&queryParm.qy_genParm);
	if( queryParm.qy_genParm.gp_errorHandle != NULL )
	{
		API_DisplayStatus("IIapi_query", queryParm.qy_genParm.gp_status);
		/* Display error messages if there are...*/
		API_DisplayErrorInfo(queryParm.qy_genParm.gp_errorHandle);	
	}
	
	return(queryParm);
}

/***********************************************************************************-
**
** Function Name: API_GetDescriptor 					            			    **
** Description:   Communicates the format of the data to be returned with           -
**
**                IIapi_getcolumns()                                                -
**
** Input:         Statement handle identifying the query that requested data		**
**                from the DBMS server                                              -
**
** Return value:  Number of Columns                    								**
************************************************************************************-
**/
int API_GetDescriptor(II_PTR stmtHandle, IIAPI_GETDESCRPARM* getDescrP)
{
	getDescrP->gd_genParm.gp_callback = NULL;
    getDescrP->gd_genParm.gp_closure = NULL;
    getDescrP->gd_stmtHandle = stmtHandle;

	IIapi_getDescriptor(getDescrP);

	/* wait until the task is completed... */
	API_Wait(&getDescrP->gd_genParm);

	if( getDescrP->gd_genParm.gp_errorHandle != NULL )
	{
		API_DisplayStatus("IIapi_getDescriptor", getDescrP->gd_genParm.gp_status);
		/* Display error messages if there are...*/
		API_DisplayErrorInfo(getDescrP->gd_genParm.gp_errorHandle);	
	}

	return( getDescrP->gd_descriptorCount );
}

void API_printLine()
{
	printf("------------------------------------\n\n");
}

int main()
{
	II_PTR					envHandle;
	IIAPI_CONNPARM          iiapi_connparm;
	II_PTR					connHandle;
	II_PTR					tranHandle;

	/* Initialize the environment */
	envHandle = API_Initialize(-1);

	/* Connect to Name Server */
	iiapi_connparm.co_genParm.gp_callback = NULL;
	iiapi_connparm.co_target = NULL;
	iiapi_connparm.co_username = NULL;
	iiapi_connparm.co_password = NULL;
	iiapi_connparm.co_timeout = -1;
    iiapi_connparm.co_connHandle = envHandle;
	iiapi_connparm.co_tranHandle = NULL;
	iiapi_connparm.co_type = IIAPI_CT_NS;

	connHandle = API_Connect(&iiapi_connparm);

	/* set auto commit on */
	tranHandle = API_Autocommit(connHandle, NULL);
	
	printf("#\n");
	printf("# Destroy all global attribute data entries for vnode 'apitest' that includ-
e the connection_type\n");
	printf("#\n");
	API_ExecQuery("Destroy Global attribute apitest connection_type *", connHandle, tra-
nHandle);

	printf("#\n");
	printf("# Destroy a global connection data entry on vnode 'apitest' where:\n");
	printf("# * net_addr = *\n");
	printf("# * protocol = *\n");
	printf("# * port     = *\n");
	printf("#\n");
	API_ExecQuery("Destroy Global connection apitest * * *", connHandle, tranHandle);

	printf("#\n");
	printf("# Destroy a private login on vnode 'apitest'\n");
	printf("#\n");
	API_ExecQuery("DE PR L apitest", connHandle, tranHandle);

	printf("#\n");
	printf("# Destroy a global login on vnode 'apitest'\n");
	printf("#\n");
	API_ExecQuery("Destroy Global Login apitest", connHandle, tranHandle);

	printf("#\n");
	printf("# Create a private authorization for vnode 'apitest' for user 'ingres'\n");
	printf("#\n");
	API_ExecQuery("C P L apitest ingres ingres", connHandle, tranHandle);

	printf("#\n");
	printf("# Define an Installation Password for the local installation, which has a l-
ocal vnode name of 'apitest'\n");
	printf("#\n");
	API_ExecQuery("create gl login apitest * apitest_password", connHandle, tranHandle)-
;

	printf("#\n");
	printf("# Create a global connection data entry on vnode 'apitest' where:\n");
	printf("# * net_addr = apitest\n");
	printf("# * protocol = TCP/IP\n");
	printf("# * port     = II\n");
	printf("#\n");
	API_ExecQuery("C G C apitest apitest tcp_ip II", connHandle, tranHandle);

	printf("#\n");
	printf("# Create a global connection data entry on vnode 'apitest' where:\n");
	printf("# * net_addr = apitest\n");
	printf("# * protocol = wintcp\n");
	printf("# * port     = I2\n");
	printf("#\n");
	API_ExecQuery("C G C apitest apitest wintcp I2", connHandle, tranHandle);

	printf("#\n");
	printf("# Display global connection data entries on vnode 'apitest' where:\n");
	printf("# * net_addr = apitest\n");
	printf("# * protocol = *\n");
	printf("# * port     = *\n");
	printf("#\n");
	API_Show("show global connection apitest apitest * *", connHandle, tranHandle);

	printf("#\n");
	printf("# Create a global attribute data entry on vnode 'apitest' where:\n");
	printf("# * attr_name  = connection_type\n");
	printf("# * attr_value = direct\n");
	printf("#\n");
	API_ExecQuery("C G A apitest connection_type direct", connHandle, tranHandle);

	printf("#\n");
	printf("# Create a global attribute data entry on vnode 'apitest' where:\n");
	printf("# * attr_name  = connection_type\n");
	printf("# * attr_value = direct\n");
	printf("#\n");
	API_ExecQuery("C G A apitest connection_type direct", connHandle, tranHandle);

	printf("#\n");
	printf("# Display global attribute data entries on vnode 'apitest' where:\n");
	printf("# * attr_name  = *\n");
	printf("# * attr_value = *\n");
	printf("#\n");
	API_Show("show G attribute apitest * *", connHandle, tranHandle);

	printf("#\n");
	printf("# Destroy all global attribute data entries for vnode 'apitest' that includ-
e the connection_type\n");
	printf("#\n");
	API_ExecQuery("Destroy Global attribute apitest connection_type *", connHandle, tra-
nHandle);

	printf("#\n");
	printf("# Destroy a global connection data entry on vnode 'apitest' where:\n");
	printf("# * net_addr = *\n");
	printf("# * protocol = *\n");
	printf("# * port     = *\n");
	printf("#\n");
	API_ExecQuery("Destroy Global connection apitest * * *", connHandle, tranHandle);

	printf("#\n");
	printf("# Destroy a private login on vnode 'apitest'\n");
	printf("#\n");
	API_ExecQuery("DE PR L apitest", connHandle, tranHandle);

	printf("#\n");
	printf("# Destroy a global login on vnode 'apitest'\n");
	printf("#\n");
	API_ExecQuery("Destroy Global Login apitest", connHandle, tranHandle);

	printf("#\n");
	printf("# Display global connection data entries on vnode 'apitest' where:\n");
	printf("# * net_addr = apitest\n");
	printf("# * protocol = *\n");
	printf("# * port     = *\n");
	printf("#\n");
	API_Show("show global connection apitest apitest * *", connHandle, tranHandle);

	printf("#\n");
	printf("# Display private connection data entries on vnode 'apitest' where:\n");
	printf("# * net_addr = apitest\n");
	printf("# * protocol = *\n");
	printf("# * port     = *\n");
	printf("#\n");
	API_Show("show PR connection apitest apitest * *", connHandle, tranHandle);

	/* set auto commit off */
	API_Autocommit(NULL, tranHandle);

	/* disconnect from the server */
	API_Disconnect(connHandle, iiapi_connparm.co_target);

	/* release API environment */
	API_ReleaseEnv(envHandle);
	/* terminate API */
	API_Terminate();

	return (0);
}
!!
? sepcc nameserver 
<<
>>
<< IF (NT_GENERIC||VMS) 
nameserver.c
>>
.if (VMS)
? seplnk -a nameserver
<<
>>
.else
? seplnk nameserver 
<<
>>
.endif
? qasetuser ingres run nameserver.exe
<<
Initializing API environment...
Successfully, initialized API environment
IIapi_initialize returned status = IIAPI_ST_SUCCESS
------------------------------------

Establishing a connection to 'LOCAL machine' 
IIapi_connect returned status = IIAPI_ST_SUCCESS
Successfully, connected to 'LOCAL machine'
------------------------------------

set autocommit ON
------------------------------------

#
# Destroy all global attribute data entries for vnode 'apitest' that include the con-
nection_type
#
SQL> Destroy Global attribute apitest connection_type *
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a global connection data entry on vnode 'apitest' where:
# * net_addr = *
# * protocol = *
# * port     = *
#
SQL> Destroy Global connection apitest * * *
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a private login on vnode 'apitest'
#
SQL> DE PR L apitest
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a global login on vnode 'apitest'
#
SQL> Destroy Global Login apitest
Executing . . .
->Statement processed
------------------------------------

#
# Create a private authorization for vnode 'apitest' for user 'ingres'
#
SQL> C P L apitest ingres ingres
Executing . . .
->Statement processed
------------------------------------

#
# Define an Installation Password for the local installation, which has a local vnod-
e name of 'apitest'
#
SQL> create gl login apitest * apitest_password
Executing . . .
->Statement processed
------------------------------------

#
# Create a global connection data entry on vnode 'apitest' where:
# * net_addr = apitest
# * protocol = TCP/IP
# * port     = II
#
SQL> C G C apitest apitest tcp_ip II
Executing . . .
->Statement processed
------------------------------------

#
# Create a global connection data entry on vnode 'apitest' where:
# * net_addr = apitest
# * protocol = wintcp
# * port     = I2
#
SQL> C G C apitest apitest wintcp I2
Executing . . .
->Statement processed
------------------------------------

#
# Display global connection data entries on vnode 'apitest' where:
# * net_addr = apitest
# * protocol = *
# * port     = *
#
SQL> show global connection apitest apitest * *
Executing . . .

	type: G
	vnode: apitest
	network_address: apitest
	protocol: tcp_ip
	listen_address: II
=========================================
	type: G
	vnode: apitest
	network_address: apitest
	protocol: wintcp
	listen_address: I2
=========================================
Error in IIapi_wait
IIapi_wait returned status = IIAPI_ST_NO_DATA
->Statement processed
------------------------------------

#
# Create a global attribute data entry on vnode 'apitest' where:
# * attr_name  = connection_type
# * attr_value = direct
#
SQL> C G A apitest connection_type direct
Executing . . .
->Statement processed
------------------------------------

#
# Create a global attribute data entry on vnode 'apitest' where:
# * attr_name  = connection_type
# * attr_value = direct
#
SQL> C G A apitest connection_type direct
Executing . . .
->Statement processed
------------------------------------

#
# Display global attribute data entries on vnode 'apitest' where:
# * attr_name  = *
# * attr_value = *
#
SQL> show G attribute apitest * *
Executing . . .

	type: G
	vnode: apitest
	attribute_name: connection_type
	attribute_value: direct
=========================================
Error in IIapi_wait
IIapi_wait returned status = IIAPI_ST_NO_DATA
->Statement processed
------------------------------------

#
# Destroy all global attribute data entries for vnode 'apitest' that include the con-
nection_type
#
SQL> Destroy Global attribute apitest connection_type *
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a global connection data entry on vnode 'apitest' where:
# * net_addr = *
# * protocol = *
# * port     = *
#
SQL> Destroy Global connection apitest * * *
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a private login on vnode 'apitest'
#
SQL> DE PR L apitest
Executing . . .
->Statement processed
------------------------------------

#
# Destroy a global login on vnode 'apitest'
#
SQL> Destroy Global Login apitest
Executing . . .
->Statement processed
------------------------------------

#
# Display global connection data entries on vnode 'apitest' where:
# * net_addr = apitest
# * protocol = *
# * port     = *
#
SQL> show global connection apitest apitest * *
Executing . . .

Error in IIapi_wait
IIapi_wait returned status = IIAPI_ST_NO_DATA
->Statement processed
------------------------------------

#
# Display private connection data entries on vnode 'apitest' where:
# * net_addr = apitest
# * protocol = *
# * port     = *
#
SQL> show PR connection apitest apitest * *
Executing . . .

Error in IIapi_wait
IIapi_wait returned status = IIAPI_ST_NO_DATA
->Statement processed
------------------------------------

set autocommit OFF
------------------------------------

Disconnecting from 'LOCAL machine'... 
Successfully, disconnected from 'LOCAL machine'
IIapi_disconnect returned status = IIAPI_ST_SUCCESS
------------------------------------

Releasing API environment...
Successfully, released API environment
IIapi_releaseEnv returned status = IIAPI_ST_SUCCESS
------------------------------------

Terminating API...
Successfully, terminated API
IIapi_terminate returned status = IIAPI_ST_SUCCESS
			*** THE END ***
>>
? delete iiapi_edit.com 
<<
~
>>
? delete makeiiapi.bat 
<<
~
>>
? delete nameserver.obj 
<<
~
>>
? delete nameserver.c
<<
~
>>
? delete nameserver.o 
<<
~
>>
? delete nameserver.exe 
<<
~
>>
? delete iiapi.h 
<<
~
>>
? delete iiapi.tmp 
<<
~
>>
? delete iiapidep.h 
<<
~
>>


Ending at: Wed Dec 15 14:56:37 1999
